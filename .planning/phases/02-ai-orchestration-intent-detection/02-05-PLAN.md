---
phase: 02-ai-orchestration-intent-detection
plan: 05
type: execute
wave: 3
depends_on: [02-02, 02-03, 02-04]
files_modified:
  - lib/ai/agents/base-agent.ts
  - lib/ai/tools/file-tools.ts
  - lib/ai/tools/command-tools.ts
  - app/api/agent/execute/route.ts
  - components/chat/agent-progress-card.tsx
  - components/chat/message-content.tsx
autonomous: false

must_haves:
  truths:
    - "Agent can create, read, modify, and delete files"
    - "Agent can execute terminal commands securely"
    - "User sees real-time progress as agent executes tools"
    - "Each tool execution appears in activity stream with timestamp"
    - "Agent execution can be cancelled mid-execution"
    - "Errors show specific recovery suggestions"
  artifacts:
    - path: "lib/ai/agents/base-agent.ts"
      provides: "ToolLoopAgent configuration with file and command tools"
      exports: ["createWorkflowAgent"]
    - path: "lib/ai/tools/file-tools.ts"
      provides: "File operation tools (create, read, modify, delete)"
      exports: ["createFileTool", "readFileTool", "modifyFileTool", "deleteFileTool"]
    - path: "lib/ai/tools/command-tools.ts"
      provides: "Secure command execution tool"
      exports: ["runCommandTool"]
    - path: "app/api/agent/execute/route.ts"
      provides: "Agent execution endpoint with streaming"
      min_lines: 100
    - path: "components/chat/agent-progress-card.tsx"
      provides: "Real-time progress display component"
      exports: ["AgentProgressCard"]
  key_links:
    - from: "app/api/agent/execute/route.ts"
      to: "lib/ai/agents/base-agent.ts"
      via: "agent.stream() call"
      pattern: "agent\\.stream\\(\\{messages"
    - from: "lib/ai/agents/base-agent.ts"
      to: "lib/ai/tools/*"
      via: "tool registration in ToolLoopAgent"
      pattern: "tools:\\s*\\{"
    - from: "components/chat/agent-progress-card.tsx"
      to: "app/api/agent/execute/route.ts"
      via: "Server-Sent Events subscription"
      pattern: "EventSource.*api/agent/execute"
---

<objective>
Implement basic agent execution with file operations and terminal commands, streaming real-time progress to users.

Purpose: Enable agents to take tangible actions on behalf of users (ORCH-03) - creating files, running commands, with full transparency through progress streaming. Establishes "Claude Cowork" experience with real execution capability.

Output: Working agent system with file and command tools, streaming execution API, and real-time progress UI.
</objective>

<execution_context>
@/Users/christian.baverstock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/christian.baverstock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-ai-orchestration-intent-detection/02-CONTEXT.md
@.planning/phases/02-ai-orchestration-intent-detection/02-RESEARCH.md
@.planning/phases/02-ai-orchestration-intent-detection/02-02-SUMMARY.md
@.planning/phases/02-ai-orchestration-intent-detection/02-03-SUMMARY.md
@.planning/phases/02-ai-orchestration-intent-detection/02-04-SUMMARY.md
@lib/ai/client.ts
</context>

<tasks>

<task type="auto">
  <name>Create secure agent tools for file operations and commands</name>
  <files>lib/ai/tools/file-tools.ts, lib/ai/tools/command-tools.ts</files>
  <action>
Implement agent tools following AI SDK tool() pattern from research (Pattern 2 + Code Examples):

**Create lib/ai/tools/file-tools.ts:**
```typescript
import { tool } from 'ai';
import { z } from 'zod';
import { promises as fs } from 'fs';
import path from 'path';

export const createFileTool = tool({
  description: 'Create a new file with content',
  parameters: z.object({
    path: z.string().describe('File path relative to project root'),
    content: z.string().describe('File content'),
  }),
  execute: async ({ path: filePath, content }) => {
    try {
      // Security: Prevent path traversal attacks
      const safePath = path.resolve(process.cwd(), filePath);
      if (!safePath.startsWith(process.cwd())) {
        return { success: false, error: 'Invalid path - must be within project', recovery: 'Use a relative path like "src/workflow.ts"' };
      }

      // Create directory if needed
      await fs.mkdir(path.dirname(safePath), { recursive: true });
      await fs.writeFile(safePath, content, 'utf-8');

      return { success: true, path: filePath, bytesWritten: content.length };
    } catch (error: any) {
      return {
        success: false,
        error: error.message,
        recovery: 'Check file path and permissions, or try a different location',
      };
    }
  },
});

export const readFileTool = tool({
  description: 'Read contents of a file',
  parameters: z.object({
    path: z.string().describe('File path relative to project root'),
  }),
  execute: async ({ path: filePath }) => {
    try {
      const safePath = path.resolve(process.cwd(), filePath);
      if (!safePath.startsWith(process.cwd())) {
        return { success: false, error: 'Invalid path' };
      }

      const content = await fs.readFile(safePath, 'utf-8');
      return { success: true, content, path: filePath };
    } catch (error: any) {
      return { success: false, error: error.message };
    }
  },
});

// Add modifyFileTool and deleteFileTool following same pattern
```

**Create lib/ai/tools/command-tools.ts:**
```typescript
import { tool } from 'ai';
import { z } from 'zod';
import { execFile } from 'child_process';
import { promisify } from 'util';

const execFileAsync = promisify(execFile);

export const runCommandTool = tool({
  description: 'Execute a shell command safely',
  parameters: z.object({
    command: z.string().describe('Command to execute (e.g., npm, git, ls)'),
    args: z.array(z.string()).describe('Command arguments'),
  }),
  execute: async ({ command, args }) => {
    try {
      // Security: Use execFile (not exec) to prevent shell injection
      // Research explicitly warns: "Use execFile for security, not exec()"
      // Whitelist safe commands
      const allowedCommands = ['npm', 'git', 'ls', 'cat', 'mkdir', 'node', 'echo'];
      if (!allowedCommands.includes(command)) {
        return {
          success: false,
          error: `Command '${command}' not allowed`,
          recovery: `Use one of: ${allowedCommands.join(', ')}`,
        };
      }

      // execFile prevents shell injection by passing args as array
      const { stdout, stderr } = await execFileAsync(command, args, {
        cwd: process.cwd(),
        timeout: 30000, // 30 second timeout
        maxBuffer: 1024 * 1024, // 1MB buffer
      });

      return { success: true, stdout, stderr, command: `${command} ${args.join(' ')}` };
    } catch (error: any) {
      return {
        success: false,
        error: error.message,
        stderr: error.stderr || '',
        recovery: 'Check command syntax and arguments',
      };
    }
  },
});
```

Key security measures (per research Common Pitfalls + security warning):
- Path traversal prevention with safePath checks
- **CRITICAL: execFile instead of exec() to prevent shell injection**
- Command whitelist
- Timeout protection (30s)
- Buffer limits (1MB)
- Structured error returns with recovery suggestions

Implementation note: We use raw execFile (not exec) per research and security warnings. The args array prevents shell injection attacks that would be possible with exec().
  </action>
  <verify>Tool files compile without errors, can be imported, Zod schemas validate parameters</verify>
  <done>File and command tools implemented with security safeguards (execFile, path validation, whitelist), structured return types with success/error/recovery fields</done>
</task>

<task type="auto">
  <name>Build agent with ToolLoopAgent pattern</name>
  <files>lib/ai/agents/base-agent.ts, app/api/agent/execute/route.ts</files>
  <action>
Create agent using AI SDK ToolLoopAgent (research Pattern 2):

**Create lib/ai/agents/base-agent.ts:**
```typescript
import { ToolLoopAgent } from 'ai';
import { gemini } from '@/lib/ai/client';
import { createFileTool, readFileTool, modifyFileTool, deleteFileTool } from '@/lib/ai/tools/file-tools';
import { runCommandTool } from '@/lib/ai/tools/command-tools';

export function createWorkflowAgent() {
  return new ToolLoopAgent({
    model: gemini,
    system: `You are a workflow automation agent with file system and terminal access.

Execute user requests by calling appropriate tools. Be precise and careful:
- Confirm file paths before writing
- Use relative paths from project root
- Show command output to user
- Explain what each action accomplishes

For errors:
- Provide specific recovery suggestions
- Offer alternative approaches
- Ask for clarification if needed`,
    tools: {
      createFile: createFileTool,
      readFile: readFileTool,
      modifyFile: modifyFileTool,
      deleteFile: deleteFileTool,
      runCommand: runCommandTool,
    },
    onStepFinish: async (stepResult) => {
      // Log for debugging - actual progress streaming in API route
      console.log('Agent step:', {
        toolCalls: stepResult.toolCalls?.map(tc => tc.toolName),
        text: stepResult.text,
      });
    },
  });
}
```

**Create app/api/agent/execute/route.ts:**
```typescript
import { auth } from '@/app/(auth)/auth';
import { createWorkflowAgent } from '@/lib/ai/agents/base-agent';
import { getConversationMessages, createMessage, retrieveContext, formatContextForPrompt } from '@/lib/db/queries';

export const maxDuration = 60; // Agent operations can take longer

export async function POST(req: Request) {
  const session = await auth();
  if (!session?.user?.id) {
    return new Response('Unauthorized', { status: 401 });
  }

  try {
    const { conversationId, messageId } = await req.json();

    // Load conversation messages for context
    const messages = await getConversationMessages(conversationId);

    // Load user context
    const contextPrompt = await formatContextForPrompt(conversationId);

    // Create agent with context
    const agent = createWorkflowAgent();

    // Pass last ~10 messages to agent (user decision)
    const recentMessages = messages.slice(-10);

    // Stream agent execution
    const result = await agent.stream({
      messages: recentMessages,
      system: agent.system + contextPrompt,
      abortSignal: req.signal,
    });

    // Save progress updates as messages
    // This is simplified - full implementation in Phase 3
    return result.toDataStreamResponse();
  } catch (error) {
    console.error('Agent execution error:', error);
    return new Response(JSON.stringify({
      success: false,
      error: 'Agent execution failed',
    }), { status: 500 });
  }
}
```

Follows research patterns exactly. Agent has tools, streams progress, receives user context. API endpoint handles authentication and message context loading.
  </action>
  <verify>Agent can be created, execute route accepts POST requests, streaming response works without errors</verify>
  <done>ToolLoopAgent configured with file and command tools, execution API endpoint streams agent actions, context injection works</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Phase 2 orchestration system:
- Intent classification detecting action verbs vs questions
- Agent confirmation UI with Proceed/Cancel
- Context memory across sessions
- Basic agent execution with file operations and commands
- Real-time progress streaming
  </what-built>
  <how-to-verify>
**Test 1: Intent Detection**
1. Send "How do I create a workflow?" → Should get conversational response (no agent card)
2. Send "Create a workflow that backs up my data daily" → Should get agent request card with summary

**Test 2: Agent Confirmation Flow**
1. When agent card appears, expand "View details" → See action list
2. Click Cancel → AI should offer alternatives
3. Send another action request
4. Click Proceed → Card updates to "Working..." status

**Test 3: Destructive Operations**
1. Send "Delete all my test files"
2. Verify red border on agent card
3. Verify checkbox "I understand this cannot be undone" appears
4. Verify Proceed button disabled until checkbox checked
5. Check checkbox, click Proceed

**Test 4: Agent Execution**
1. Send "Create a file called test.txt with content 'Hello World'"
2. Click Proceed
3. Watch for progress updates in UI
4. Verify file created: `ls test.txt` should show file
5. Verify content: `cat test.txt` should show "Hello World"

**Test 5: Context Memory**
1. Send "I'm working on a project using Next.js and PostgreSQL"
2. Wait for response
3. Close browser or clear cookies
4. Open new session with same conversation
5. Send "What stack am I using?" → AI should mention Next.js and PostgreSQL from context

**Test 6: Command Execution**
1. Send "Run npm --version"
2. Click Proceed
3. Verify command output appears in chat

**Test 7: Error Handling**
1. Send "Create a file at /etc/secret.txt" (invalid path)
2. Click Proceed
3. Verify error message with recovery suggestion appears

**Expected Results:**
- ✅ Intent detection routes correctly (chat vs agent)
- ✅ Agent cards display with proper styling
- ✅ Destructive operations show warnings
- ✅ File operations execute successfully
- ✅ Commands run with output display
- ✅ Context persists across sessions
- ✅ Errors show recovery suggestions
  </how-to-verify>
  <resume-signal>
Type "approved" when all tests pass, or describe specific issues to fix.

If issues found, describe what failed and I'll create a gap closure plan.
  </resume-signal>
</task>

</tasks>

<verification>
Complete verification in checkpoint task above. This checkpoint validates entire Phase 2 functionality:
- All 7 ORCH requirements (ORCH-01 through ORCH-07)
- Intent classification accuracy
- Confirmation flow UX
- Agent execution capability
- Context memory persistence
- Error handling and recovery
</verification>

<success_criteria>
- [x] Agent can create, read, modify, delete files securely
- [x] Agent can execute whitelisted terminal commands using execFile (not exec)
- [x] Real-time progress streams to user during execution
- [x] Tool executions appear in activity stream with timestamps
- [x] Errors return structured messages with recovery suggestions
- [x] Agent execution can be cancelled via abort signal
- [x] Security: path traversal prevented, command whitelist enforced, execFile used (per research + warning)
- [x] Phase 2 goal achieved: AI intelligently routes chat vs agent with full transparency
</success_criteria>

<output>
After completion, create `.planning/phases/02-ai-orchestration-intent-detection/02-05-SUMMARY.md`
</output>
