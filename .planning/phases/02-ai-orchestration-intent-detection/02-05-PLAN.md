---
phase: 02-ai-orchestration-intent-detection
plan: 05
type: execute
wave: 3
depends_on: [02-02, 02-03, 02-04]
files_modified:
  - lib/ai/agents/stub-agent.ts
  - app/api/agent/execute/route.ts
autonomous: false

must_haves:
  truths:
    - "Agent confirmation shows what actions would be taken"
    - "User sees simulated progress updates after confirming"
    - "Mock tool executions appear in UI with timestamps"
    - "Full orchestration UX flow works end-to-end (intent → confirm → mock progress)"
  artifacts:
    - path: "lib/ai/agents/stub-agent.ts"
      provides: "Stub agent returning mock progress responses"
      exports: ["createStubAgent", "AgentProgressUpdate"]
      min_lines: 40
    - path: "app/api/agent/execute/route.ts"
      provides: "Agent execution endpoint with SSE mock streaming"
      min_lines: 50
  key_links:
    - from: "app/api/agent/execute/route.ts"
      to: "lib/ai/agents/stub-agent.ts"
      via: "stub agent call for mock responses"
      pattern: "createStubAgent"
---

<objective>
Complete Phase 2 orchestration UX with stub agent execution to validate confirmation flows and progress visualization.

Purpose: Verify the full orchestration flow (intent detection → confirmation → progress display) works end-to-end without implementing actual agent execution. Real execution with ToolLoopAgent, file-tools, and command-tools moves to Phase 3 per roadmap boundary ("decides when to summon" not "executes").

Output: Working orchestration UX with stub agent responses, validated confirmation flows, and progress visualization ready for Phase 3 real execution.
</objective>

<execution_context>
@/Users/christian.baverstock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/christian.baverstock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-ai-orchestration-intent-detection/02-CONTEXT.md
@.planning/phases/02-ai-orchestration-intent-detection/02-RESEARCH.md
@.planning/phases/02-ai-orchestration-intent-detection/02-02-SUMMARY.md
@.planning/phases/02-ai-orchestration-intent-detection/02-03-SUMMARY.md
@.planning/phases/02-ai-orchestration-intent-detection/02-04-SUMMARY.md
@lib/ai/client.ts
</context>

<tasks>

<task type="auto">
  <name>Create stub agent returning mock responses</name>
  <files>lib/ai/agents/stub-agent.ts</files>
  <action>
Create stub agent that returns mock progress responses (actual ToolLoopAgent and tools moved to Phase 3):

**Create lib/ai/agents/stub-agent.ts:**
```typescript
export interface AgentProgressUpdate {
  type: 'tool_call' | 'tool_result' | 'text' | 'complete';
  timestamp: number;
  content: string;
  toolName?: string;
  success?: boolean;
}

export function createStubAgent() {
  return {
    async* execute(taskDescription: string): AsyncGenerator<AgentProgressUpdate> {
      // Simulate thinking
      yield {
        type: 'text',
        timestamp: Date.now(),
        content: `Analyzing request: ${taskDescription}`,
      };

      await delay(500);

      // Simulate tool call
      yield {
        type: 'tool_call',
        timestamp: Date.now(),
        content: 'Creating file: workflow.ts',
        toolName: 'createFile',
      };

      await delay(800);

      // Simulate tool result
      yield {
        type: 'tool_result',
        timestamp: Date.now(),
        content: 'File created successfully (mock)',
        toolName: 'createFile',
        success: true,
      };

      await delay(500);

      // Simulate completion
      yield {
        type: 'complete',
        timestamp: Date.now(),
        content: 'Task completed successfully (stub implementation)',
      };
    },
  };
}

function delay(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}
```

Implementation note: This stub validates the orchestration UX flow (confirmation, progress display) without actual execution. Real ToolLoopAgent, file-tools, and command-tools will be implemented in Phase 3 Plan 03-01 per roadmap boundary.
  </action>
  <verify>Stub agent compiles, returns mock progress updates, delay function works correctly</verify>
  <done>Stub agent implemented returning mock progress updates with realistic delays, validates orchestration UX without actual execution</done>
</task>

<task type="auto">
  <name>Create agent execution API with stub integration</name>
  <files>app/api/agent/execute/route.ts</files>
  <action>
Create agent execution endpoint using stub agent for mock streaming:

**Create app/api/agent/execute/route.ts:**
```typescript
import { auth } from '@/app/(auth)/auth';
import { createStubAgent } from '@/lib/ai/agents/stub-agent';

export const maxDuration = 60;

export async function POST(req: Request) {
  const session = await auth();
  if (!session?.user?.id) {
    return new Response('Unauthorized', { status: 401 });
  }

  try {
    const { taskDescription } = await req.json();

    // Create stub agent
    const agent = createStubAgent();

    // Create Server-Sent Events stream
    const stream = new ReadableStream({
      async start(controller) {
        const encoder = new TextEncoder();

        try {
          // Stream mock progress updates
          for await (const update of agent.execute(taskDescription)) {
            const data = `data: ${JSON.stringify(update)}\n\n`;
            controller.enqueue(encoder.encode(data));
          }
        } catch (error) {
          console.error('Agent execution error:', error);
          const errorData = `data: ${JSON.stringify({
            type: 'error',
            timestamp: Date.now(),
            content: 'Agent execution failed',
          })}\n\n`;
          controller.enqueue(encoder.encode(errorData));
        } finally {
          controller.close();
        }
      },
    });

    return new Response(stream, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
      },
    });
  } catch (error) {
    console.error('API error:', error);
    return new Response(JSON.stringify({
      success: false,
      error: 'Failed to start agent execution',
    }), { status: 500 });
  }
}
```

Implementation note: Uses Server-Sent Events (SSE) for streaming mock progress updates. Real agent integration with context injection and message storage will be added in Phase 3.
  </action>
  <verify>API endpoint returns SSE stream, mock updates arrive in correct format, unauthorized requests return 401</verify>
  <done>Agent execution API created with SSE streaming, integrates stub agent for mock progress, validates full streaming flow</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Phase 2 orchestration UX with stub execution:
- Intent classification detecting action verbs vs questions
- Agent confirmation UI with Proceed/Cancel
- Destructive operation warnings
- Context memory across sessions
- Mock agent execution with progress streaming
  </what-built>
  <how-to-verify>
**Test 1: Intent Detection**
1. Send "How do I create a workflow?" → Should get conversational response (no agent card)
2. Send "Create a workflow that backs up my data daily" → Should get agent request card with summary

**Test 2: Agent Confirmation Flow**
1. When agent card appears, expand "View details" → See action list
2. Click Cancel → AI should offer alternatives
3. Send another action request
4. Click Proceed → Card updates to "Working..." status

**Test 3: Destructive Operations**
1. Send "Delete all my test files"
2. Verify red border on agent card
3. Verify checkbox "I understand this cannot be undone" appears
4. Verify Proceed button disabled until checkbox checked

**Test 4: Mock Agent Execution**
1. Send "Create a file called test.txt with content 'Hello World'"
2. Click Proceed
3. Watch for mock progress updates in UI:
   - "Analyzing request" text appears
   - Tool call "Creating file: workflow.ts" appears
   - Tool result "File created successfully (mock)" appears
   - Completion message appears
4. Verify progress updates have timestamps and proper styling

**Test 5: Context Memory (from Plan 02-04)**
1. Send "I'm working on a project using Next.js and PostgreSQL"
2. Wait for response
3. Close browser or clear cookies
4. Open new session with same conversation
5. Send "What stack am I using?" → AI should mention Next.js and PostgreSQL from context

**Expected Results:**
- ✅ Intent detection routes correctly (chat vs agent)
- ✅ Agent cards display with proper styling
- ✅ Destructive operations show warnings
- ✅ Mock progress updates stream correctly
- ✅ Progress card displays status and activity stream
- ✅ Context persists across sessions (validates 02-04 integration)
- ✅ Full orchestration UX flow works end-to-end

NOTE: Actual file operations, command execution, and real agent execution are moved to Phase 3 per roadmap boundary.
  </how-to-verify>
  <resume-signal>
Type "approved" when all tests pass, or describe specific issues to fix.

If issues found, describe what failed and I'll create a gap closure plan.
  </resume-signal>
</task>

</tasks>

<verification>
Complete verification in checkpoint task above. This checkpoint validates Phase 2 orchestration UX:
- Intent classification (ORCH-01, ORCH-02)
- Confirmation flows with transparency (ORCH-03)
- Context memory persistence (ORCH-05, ORCH-06, ORCH-07)
- Progress visualization with mock execution
- Full orchestration flow end-to-end

Actual agent execution validation (file operations, command execution, error recovery) moves to Phase 3 verification.
</verification>

<success_criteria>
- [x] Stub agent returns mock progress updates in correct format
- [x] SSE streaming delivers updates to client in real-time
- [x] Progress card displays mock tool calls with timestamps
- [x] Activity stream shows status progression (analyzing → tool call → result → complete)
- [x] Agent confirmation UI integrates with stub execution flow
- [x] Context from 02-04 works with agent summoning
- [x] Phase 2 goal achieved: AI intelligently decides when to respond conversationally vs. summon agent (with mock execution for UX validation)
- [x] Real execution implementation clearly scoped to Phase 3
</success_criteria>

<output>
After completion, create `.planning/phases/02-ai-orchestration-intent-detection/02-05-SUMMARY.md`
</output>
