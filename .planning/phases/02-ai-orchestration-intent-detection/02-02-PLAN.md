---
phase: 02-ai-orchestration-intent-detection
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/ai/prompts.ts
  - lib/ai/intent-classifier.ts
  - lib/types/agent.ts
  - app/api/chat/route.ts
autonomous: true

must_haves:
  truths:
    - "AI detects action verbs (Create, Build, Deploy, Delete) as agent intent"
    - "Questions and discussions remain conversational"
    - "Ambiguous intent defaults to chat with optional build offer"
    - "Intent detection returns structured output with confidence score"
  artifacts:
    - path: "lib/ai/prompts.ts"
      provides: "Orchestration system prompt with intent detection rules"
      contains: "ACTION VERBS trigger agent"
    - path: "lib/ai/intent-classifier.ts"
      provides: "Intent detection function using structured output"
      exports: ["detectIntent"]
    - path: "lib/types/agent.ts"
      provides: "TypeScript types for intent detection and agent messages"
      exports: ["IntentResult", "AgentRequestMetadata"]
    - path: "app/api/chat/route.ts"
      provides: "Updated chat endpoint with intent detection"
      contains: "detectIntent"
  key_links:
    - from: "app/api/chat/route.ts"
      to: "lib/ai/intent-classifier.ts"
      via: "function call before streaming"
      pattern: "await detectIntent\\(messages\\)"
    - from: "lib/ai/intent-classifier.ts"
      to: "lib/ai/prompts.ts"
      via: "uses orchestration prompt"
      pattern: "import.*orchestrationPrompt"
---

<objective>
Implement prompt-based intent classification that distinguishes conversational queries from action requests requiring agent execution.

Purpose: Enable AI to intelligently route user requests (ORCH-01) - action verbs trigger agent summoning with confirmation, questions remain conversational. System explains its decision (ORCH-02) with structured output.

Output: Intent detection system using Gemini structured output with Zod validation, integrated into chat API.
</objective>

<execution_context>
@/Users/christian.baverstock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/christian.baverstock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-ai-orchestration-intent-detection/02-CONTEXT.md
@.planning/phases/02-ai-orchestration-intent-detection/02-RESEARCH.md
@lib/ai/client.ts
@lib/ai/prompts.ts
@app/api/chat/route.ts
</context>

<tasks>

<task type="auto">
  <name>Create orchestration system prompt</name>
  <files>lib/ai/prompts.ts</files>
  <action>
Add orchestrationPrompt to lib/ai/prompts.ts implementing user's intent detection rules:

```typescript
export const orchestrationPrompt = `You are a helpful AI assistant with agent capabilities.

INTENT DETECTION RULES (user-specified):
- ACTION VERBS trigger agent summoning: "Create", "Build", "Deploy", "Delete", "Modify", "Update"
- QUESTIONS remain conversational: "How", "What", "Why", "Explain", "Can you tell me"
- When ambiguous, default to conversation but offer: "Would you like me to build this for you?"

EXAMPLES:
- "Create a workflow that sends daily reports" → agent_summon (explicit action verb)
- "How do I create a workflow?" → chat (question, seeking explanation)
- "Can you build this for me?" → chat with offer (ambiguous - answer then offer to build)
- "Delete all my data" → agent_summon with destructive flag (delete operation)

RESPONSE FORMAT:
For agent_summon:
{
  "intent": "agent_summon",
  "confidence": 0.95,
  "summary": "I'll create a workflow that sends you daily reports",
  "actions": ["Create workflow file", "Configure schedule", "Set up email integration"],
  "destructive": false,
  "requiresExtraConfirm": false
}

For chat:
{
  "intent": "chat",
  "confidence": 0.90,
  "response": "To create a workflow, you'll need to...",
  "offerBuild": false
}

DESTRUCTIVE OPERATIONS (require extra confirmation):
- Delete, Remove, Drop operations
- Modify or Update operations on existing data/files
- Deploy to production environments
Set destructive: true and requiresExtraConfirm: true for these.
`;
```

Keep existing systemPrompt for non-orchestration use. Export both.
  </action>
  <verify>TypeScript compiles, both systemPrompt and orchestrationPrompt are exported from lib/ai/prompts.ts</verify>
  <done>orchestrationPrompt exported from prompts.ts with intent detection rules matching user decisions from CONTEXT.md</done>
</task>

<task type="auto">
  <name>Implement intent classifier with structured output</name>
  <files>lib/ai/intent-classifier.ts, lib/types/agent.ts</files>
  <action>
Create intent detection system using AI SDK structured output (research Pattern 1 + Code Example):

1. Create lib/types/agent.ts with TypeScript types:
```typescript
export interface IntentResult {
  intent: 'chat' | 'agent_summon';
  confidence: number;
  // For chat intent
  response?: string;
  offerBuild?: boolean;
  // For agent_summon intent
  summary?: string;
  actions?: string[];
  destructive?: boolean;
  requiresExtraConfirm?: boolean;
}

export interface AgentRequestMetadata {
  summary: string;
  actions: string[];
  destructive: boolean;
  requiresExtraConfirm: boolean;
  requestedAt: string;
}
```

2. Create lib/ai/intent-classifier.ts:
```typescript
import { generateText, Output } from 'ai';
import { gemini } from '@/lib/ai/client';
import { orchestrationPrompt } from '@/lib/ai/prompts';
import { z } from 'zod';
import type { IntentResult } from '@/lib/types/agent';

const intentSchema = z.object({
  intent: z.enum(['chat', 'agent_summon']),
  confidence: z.number().min(0).max(1),
  // Chat fields
  response: z.string().optional(),
  offerBuild: z.boolean().optional(),
  // Agent summon fields
  summary: z.string().optional(),
  actions: z.array(z.string()).optional(),
  destructive: z.boolean().optional(),
  requiresExtraConfirm: z.boolean().optional(),
});

export async function detectIntent(messages: any[]): Promise<IntentResult> {
  const { output } = await generateText({
    model: gemini,
    messages,
    system: orchestrationPrompt,
    output: Output.object({
      schema: intentSchema,
    }),
  });

  return output as IntentResult;
}
```

Use AI SDK v6.0.79 Output.object() for structured responses (already in dependencies). Follows research code examples exactly.
  </action>
  <verify>TypeScript compiles without errors, detectIntent function can be imported, returns properly typed IntentResult</verify>
  <done>Intent classifier implemented with Zod validation, returns structured intent with confidence score, destructive flag, and either chat response or agent summon details</done>
</task>

<task type="auto">
  <name>Integrate intent detection into chat API</name>
  <files>app/api/chat/route.ts</files>
  <action>
Update chat API to detect intent before streaming response:

Add intent detection flow:
1. Import detectIntent from lib/ai/intent-classifier
2. After authentication and conversation setup, call detectIntent(messages)
3. If intent === 'agent_summon':
   - Create message with messageType: 'agent_request'
   - Store metadata: { summary, actions, destructive, requiresExtraConfirm, requestedAt }
   - Return JSON response (not streaming) with agent request details for UI to display confirmation card
4. If intent === 'chat':
   - Proceed with existing streamText flow
   - If offerBuild === true, append build offer to response

Preserve existing authentication, conversation management, and message saving logic. Only add intent detection as decision point before streaming.

Example flow:
```typescript
// After conversation setup, before streaming
const intent = await detectIntent(messages);

if (intent.intent === 'agent_summon') {
  // Save agent request message
  const agentMessage = await createMessage(
    activeConversationId,
    'assistant',
    intent.summary!,
    'agent_request',
    {
      summary: intent.summary,
      actions: intent.actions,
      destructive: intent.destructive,
      requiresExtraConfirm: intent.requiresExtraConfirm,
      requestedAt: new Date().toISOString(),
    }
  );

  return Response.json({
    type: 'agent_request',
    message: agentMessage,
  });
}

// Otherwise continue with existing streamText flow
```

Note: createMessage needs signature update to accept messageType and metadata parameters. Add these optional params to function in lib/db/queries.ts.
  </action>
  <verify>npm run build succeeds, TypeScript compilation passes, chat API can call detectIntent without errors</verify>
  <done>Chat API calls detectIntent for every message, routes to agent confirmation for action verbs, continues conversation for questions, user-specified intent rules enforced</done>
</task>

</tasks>

<verification>
After completion:
1. Send "Create a workflow" → AI returns agent_request with summary and actions
2. Send "How do I create a workflow?" → AI returns conversational response (streamText)
3. Send "Delete all data" → AI returns agent_request with destructive: true
4. Check intent confidence scores are realistic (0.8-1.0 range)
5. Verify chat flow still works for non-action messages
</verification>

<success_criteria>
- [x] orchestrationPrompt implements user's intent detection rules (action verbs, questions, ambiguous handling)
- [x] detectIntent function returns structured output with confidence score
- [x] Agent summon intent includes summary, actions, destructive flag per user requirements
- [x] Chat API integrates intent detection before streaming
- [x] Action verbs (Create, Build, Deploy, Delete) trigger agent_request type
- [x] Questions remain conversational with streamText flow
- [x] TypeScript types define IntentResult and AgentRequestMetadata
</success_criteria>

<output>
After completion, create `.planning/phases/02-ai-orchestration-intent-detection/02-02-SUMMARY.md`
</output>
