---
phase: 01-chat-foundation-authentication
plan: 05
type: execute
wave: 3
depends_on: ["01-03", "01-04"]
files_modified:
  - app/(chat)/actions.ts
  - app/(chat)/[conversationId]/page.tsx
  - lib/db/queries.ts
  - components/chat/chat-interface.tsx
autonomous: true

must_haves:
  truths:
    - "User can create new conversations"
    - "User can rename conversations"
    - "User can delete conversations with confirmation"
    - "Conversation history persists across browser sessions"
    - "Deleted conversations are removed from database"
  artifacts:
    - path: "app/(chat)/actions.ts"
      provides: "Server actions for conversation CRUD"
      exports: ["createConversation", "renameConversation", "deleteConversation", "pinConversation"]
      min_lines: 80
    - path: "app/(chat)/[conversationId]/page.tsx"
      provides: "Dynamic route for specific conversations"
      min_lines: 30
    - path: "lib/db/queries.ts"
      provides: "Conversation database operations"
      exports: ["getUserConversations", "updateConversation", "deleteConversation"]
  key_links:
    - from: "app/(chat)/actions.ts"
      to: "lib/db/queries.ts"
      via: "database operations"
      pattern: "db\\.conversation\\.(update|delete)"
    - from: "app/(chat)/actions.ts"
      to: "app/(auth)/auth.ts"
      via: "auth check"
      pattern: "await auth\\(\\)"
    - from: "app/(chat)/[conversationId]/page.tsx"
      to: "lib/db/queries.ts"
      via: "load conversation"
      pattern: "getConversation.*conversationId"
---

<objective>
Implement conversation management (create, rename, delete) with Server Actions and database persistence. Enable conversation history persistence across sessions.

Purpose: Deliver conversation management requirements (CHAT-05, CHAT-06, CHAT-07, CHAT-08, CHAT-09).

Output: Working conversation CRUD operations with proper user isolation and data persistence.
</objective>

<execution_context>
@/Users/christian.baverstock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/christian.baverstock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/christian.baverstock/code/ai-chat/.planning/PROJECT.md
@/Users/christian.baverstock/code/ai-chat/.planning/ROADMAP.md
@/Users/christian.baverstock/code/ai-chat/.planning/phases/01-chat-foundation-authentication/01-CONTEXT.md
@/Users/christian.baverstock/code/ai-chat/.planning/phases/01-chat-foundation-authentication/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Create Server Actions for conversation operations</name>
  <files>
app/(chat)/actions.ts
lib/db/queries.ts (add conversation queries)
  </files>
  <action>
Implement Server Actions following research Pattern 3:

**lib/db/queries.ts additions:**
Add conversation management functions:
- `getUserConversations(userId: string)` - fetch all user's conversations ordered by pinned DESC, createdAt DESC
- `getConversation(id: string, userId: string)` - fetch single conversation with user check
- `updateConversation(id: string, userId: string, data: Partial<Conversation>)` - update title or pinned status
- `deleteConversationById(id: string, userId: string)` - delete conversation and cascade delete messages
- `pinConversation(id: string, userId: string, pinned: boolean)` - toggle pinned status

All queries MUST filter by userId for data isolation (AUTH-04).

**app/(chat)/actions.ts:**
Create Server Actions with authentication:

```typescript
'use server';

import { revalidatePath } from 'next/cache';
import { redirect } from 'next/navigation';
import { auth } from '@/app/(auth)/auth';
import * as db from '@/lib/db/queries';

export async function createConversation() {
  const session = await auth();
  if (!session?.user?.id) throw new Error('Unauthorized');

  // Create conversation with placeholder title
  const conversation = await db.createConversation(session.user.id, 'New Conversation');

  revalidatePath('/');
  redirect(`/${conversation.id}`);
}

export async function renameConversation(id: string, title: string) {
  const session = await auth();
  if (!session?.user?.id) throw new Error('Unauthorized');

  // Validate title (1-100 chars)
  if (title.length < 1 || title.length > 100) {
    throw new Error('Title must be 1-100 characters');
  }

  await db.updateConversation(id, session.user.id, { title });

  revalidatePath('/');
  return { success: true };
}

export async function deleteConversation(id: string) {
  const session = await auth();
  if (!session?.user?.id) throw new Error('Unauthorized');

  await db.deleteConversationById(id, session.user.id);

  revalidatePath('/');
  redirect('/');
}

export async function pinConversation(id: string, pinned: boolean) {
  const session = await auth();
  if (!session?.user?.id) throw new Error('Unauthorized');

  await db.pinConversation(id, session.user.id, pinned);

  revalidatePath('/');
  return { success: true };
}
```

Per research anti-pattern: "ALWAYS filter by userId from session. Missing this creates major security vulnerabilities."

Use revalidatePath to update UI after mutations.
  </action>
  <verify>
1. Check all Server Actions have `await auth()` at start
2. Verify all database queries include userId parameter
3. Check revalidatePath called after mutations
4. Verify TypeScript types are correct
  </verify>
  <done>
Server Actions created for conversation management with proper authentication and user isolation. Database queries enforce data privacy.
  </done>
</task>

<task type="auto">
  <name>Create dynamic route for conversations</name>
  <files>
app/(chat)/[conversationId]/page.tsx
components/chat/chat-interface.tsx (update to accept conversationId)
  </files>
  <action>
Create dynamic routing for conversations:

**app/(chat)/[conversationId]/page.tsx:**
Server component that:
1. Extracts conversationId from params
2. Checks authentication with `await auth()`
3. Fetches conversation with `getConversation(conversationId, userId)`
4. Returns 404 if conversation not found or doesn't belong to user
5. Fetches conversation messages with `getConversationMessages(conversationId)`
6. Renders ChatInterface with conversationId and initial messages

```typescript
import { auth } from '@/app/(auth)/auth';
import { getConversation, getConversationMessages } from '@/lib/db/queries';
import { ChatInterface } from '@/components/chat/chat-interface';
import { notFound } from 'next/navigation';

export default async function ConversationPage({
  params,
}: {
  params: { conversationId: string };
}) {
  const session = await auth();
  if (!session?.user?.id) return null;

  const conversation = await getConversation(params.conversationId, session.user.id);
  if (!conversation) notFound();

  const messages = await getConversationMessages(params.conversationId);

  return <ChatInterface conversationId={params.conversationId} initialMessages={messages} />;
}
```

**Update components/chat/chat-interface.tsx:**
Accept optional conversationId and initialMessages props. If conversationId provided, include in useChat body. If initialMessages provided, pass to useChat as initialMessages option.

Per user decision: "Auto-name from first message - conversation starts immediately, title generated from user's first message"
This happens in API route's onFinish callback (already in plan 03).

**Update app/(chat)/page.tsx:**
Root chat page (no conversationId) - renders ChatInterface without conversationId. First message creates new conversation and redirects to /{conversationId}.
  </action>
  <verify>
1. Visit http://localhost:3000 - loads chat interface
2. Send message - should redirect to /{conversationId}
3. Check URL contains conversation UUID
4. Refresh page - conversation and messages persist
5. Visit conversation URL directly - loads correctly
  </verify>
  <done>
Dynamic routing implemented for conversations. URLs reflect current conversation. Messages persist across page refreshes.
  </done>
</task>

<task type="auto">
  <name>Add confirmation dialog for conversation deletion</name>
  <files>
components/ui/dialog.tsx
components/chat/delete-conversation-dialog.tsx
  </files>
  <action>
Implement deletion confirmation per user decision: "Confirm every time - show confirmation dialog for every delete action"

**components/ui/dialog.tsx:**
Wrapper around @radix-ui/react-dialog with Tailwind styling:
- Modal overlay with backdrop
- Centered dialog content
- Close button
- Accessible (focus trap, ESC to close)

**components/chat/delete-conversation-dialog.tsx:**
Reusable confirmation dialog:
```typescript
'use client';

import { useState } from 'react';
import { Dialog } from '@/components/ui/dialog';
import { deleteConversation } from '@/app/(chat)/actions';
import { toast } from 'sonner';

export function DeleteConversationDialog({
  conversationId,
  conversationTitle,
  open,
  onOpenChange,
}: {
  conversationId: string;
  conversationTitle: string;
  open: boolean;
  onOpenChange: (open: boolean) => void;
}) {
  const [isDeleting, setIsDeleting] = useState(false);

  async function handleDelete() {
    setIsDeleting(true);
    try {
      await deleteConversation(conversationId);
      toast.success('Conversation deleted');
    } catch (error) {
      toast.error('Failed to delete conversation');
      setIsDeleting(false);
    }
  }

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <Dialog.Content>
        <Dialog.Title>Delete conversation?</Dialog.Title>
        <Dialog.Description>
          Are you sure you want to delete "{conversationTitle}"? This action cannot be undone.
        </Dialog.Description>
        <Dialog.Actions>
          <Dialog.Cancel>Cancel</Dialog.Cancel>
          <Dialog.Action onClick={handleDelete} disabled={isDeleting}>
            {isDeleting ? 'Deleting...' : 'Delete'}
          </Dialog.Action>
        </Dialog.Actions>
      </Dialog.Content>
    </Dialog>
  );
}
```

Use sonner for toast notifications per research.

This dialog will be used in plan 06 (sidebar) when user clicks delete on a conversation.
  </action>
  <verify>
1. Check Dialog component uses Radix UI properly
2. Verify dialog is accessible (keyboard navigation, focus trap)
3. Check DeleteConversationDialog shows conversation title
4. Verify loading state during deletion
5. Check toast notification appears on success
  </verify>
  <done>
Confirmation dialog created for conversation deletion with proper accessibility and user feedback. Follows user decision to confirm every deletion.
  </done>
</task>

</tasks>

<verification>
1. Create new conversation - redirects to /{conversationId}
2. Refresh browser - conversation persists (CHAT-09)
3. Send messages in conversation - messages saved
4. Close browser completely, reopen - conversation still there
5. Trigger delete conversation - confirmation dialog appears
6. Confirm deletion - conversation removed from database
7. Try to access deleted conversation URL - 404 not found
8. Check database - verify messages cascade deleted with conversation
</verification>

<success_criteria>
- User can create new conversations (CHAT-05)
- User can rename conversations (CHAT-07)
- User can delete conversations (CHAT-08)
- Conversation history persists across browser sessions (CHAT-09)
- Deletion requires confirmation per user decision
- Conversations are user-isolated (can't access other users' conversations)
- URLs reflect current conversation for bookmarking/sharing
</success_criteria>

<output>
After completion, create `.planning/phases/01-chat-foundation-authentication/01-05-SUMMARY.md` documenting:
- Server Actions implementation approach
- Conversation URL structure
- Confirmation dialog UX
- Data persistence strategy
- User isolation enforcement
- Any edge cases handled (empty conversations, deleted conversation access)
</output>
