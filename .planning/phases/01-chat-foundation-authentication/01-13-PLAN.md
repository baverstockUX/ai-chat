---
phase: 01-chat-foundation-authentication
plan: 13
type: execute
wave: 1
depends_on: []
files_modified: ["components/sidebar/conversation-list.tsx", "app/(chat)/actions.ts", "app/(chat)/page.tsx", "components/chat/chat-interface.tsx"]
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Sample prompts populate message input or auto-send when clicked"
    - "User clicks sample prompt and sees their message sent to AI"
  artifacts:
    - path: "app/(chat)/actions.ts"
      provides: "createConversation accepts optional prompt parameter"
      pattern: "prompt\\?:\\s*string"
    - path: "app/(chat)/page.tsx"
      provides: "Reads prompt from URL query param and passes to ChatInterface"
      pattern: "searchParams.*prompt"
    - path: "components/chat/chat-interface.tsx"
      provides: "Auto-sends initial prompt if provided"
      pattern: "useEffect.*initialPrompt.*sendMessage"
  key_links:
    - from: "conversation-list.tsx"
      to: "createConversation server action"
      via: "passes prompt parameter"
      pattern: "createConversation\\(prompt\\)"
    - from: "createConversation"
      to: "redirect with query param"
      via: "URL encoding"
      pattern: "redirect.*prompt="
    - from: "page.tsx"
      to: "ChatInterface"
      via: "initialPrompt prop"
      pattern: "<ChatInterface.*initialPrompt"
    - from: "ChatInterface"
      to: "sendMessage"
      via: "useEffect on mount"
      pattern: "useEffect.*sendMessage.*initialPrompt"
---

<objective>
Enable sample prompts to populate or auto-send when clicked.

Purpose: Currently handleSamplePrompt creates conversation and redirects, but discards prompt text. No mechanism to pass prompt through navigation flow. Implement prompt flow: click sample → create conversation → redirect with prompt in URL → read prompt → auto-send as first message.

Output: Working sample prompt flow where clicking a prompt creates conversation and sends the prompt text as the first user message.
</objective>

<execution_context>
@/Users/christian.baverstock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/christian.baverstock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-chat-foundation-authentication/01-UAT.md
@.planning/phases/01-chat-foundation-authentication/01-05-SUMMARY.md
@.planning/phases/01-chat-foundation-authentication/01-06-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Update createConversation to accept prompt parameter</name>
  <files>app/(chat)/actions.ts</files>
  <action>
Modify createConversation server action to accept optional prompt parameter and pass it through redirect URL.

**Current signature (around line 12):**
```typescript
export async function createConversation() {
```

**Update to:**
```typescript
export async function createConversation(prompt?: string) {
```

**Current redirect (around line 24):**
```typescript
redirect(`/${conversationId}`)
```

**Update to:**
```typescript
if (prompt) {
  // URL encode prompt to handle special characters
  const encodedPrompt = encodeURIComponent(prompt)
  redirect(`/${conversationId}?prompt=${encodedPrompt}`)
} else {
  redirect(`/${conversationId}`)
}
```

**Why this works:** Server action creates conversation, then redirects to conversation URL with prompt as query parameter. Next.js preserves query params through redirect, making prompt available to page component.

**Note:** Keep existing isRedirectError filter in client components from Plan 10 - still needed.
  </action>
  <verify>grep -n "prompt\\?:\\s*string" app/(chat)/actions.ts && grep -n "encodedPrompt" app/(chat)/actions.ts</verify>
  <done>createConversation accepts optional prompt parameter and includes it in redirect URL when provided.</done>
</task>

<task type="auto">
  <name>Pass prompt to createConversation in conversation-list</name>
  <files>components/sidebar/conversation-list.tsx</files>
  <action>
Update handleSamplePrompt to pass the prompt text to createConversation.

**Current call (around line 37):**
```typescript
await createConversation()
```

**Update to:**
```typescript
await createConversation(prompt)
```

The `prompt` parameter is already available in handleSamplePrompt function signature, just needs to be passed through.

**Why this works:** Sample prompt click now passes prompt text to server action instead of discarding it. Server action includes prompt in redirect URL.
  </action>
  <verify>grep -n "createConversation(prompt)" components/sidebar/conversation-list.tsx</verify>
  <done>handleSamplePrompt passes prompt parameter to createConversation server action.</done>
</task>

<task type="auto">
  <name>Read prompt from URL and pass to ChatInterface</name>
  <files>app/(chat)/page.tsx</files>
  <action>
Update root chat page to read prompt from searchParams and pass to ChatInterface.

**Add searchParams prop to page component:**
```typescript
export default async function ChatPage({
  searchParams,
}: {
  searchParams: Promise<{ prompt?: string }>
}) {
```

**Read prompt from searchParams:**
```typescript
const params = await searchParams
const initialPrompt = params.prompt || undefined
```

**Pass to ChatInterface:**
```typescript
<ChatInterface
  conversationId={undefined}
  initialMessages={[]}
  initialPrompt={initialPrompt}
/>
```

**Why this works:** Next.js App Router passes searchParams as prop to page components. Reading and passing to ChatInterface makes prompt available for auto-send.

**Note:** Root page (/) has no conversation yet - this is the "new conversation" flow where prompt should trigger first message.
  </action>
  <verify>grep -n "searchParams.*prompt" app/(chat)/page.tsx && grep -n "initialPrompt" app/(chat)/page.tsx</verify>
  <done>Root chat page reads prompt from URL query parameter and passes to ChatInterface as initialPrompt prop.</done>
</task>

<task type="auto">
  <name>Auto-send initial prompt in ChatInterface</name>
  <files>components/chat/chat-interface.tsx</files>
  <action>
Update ChatInterface to accept initialPrompt and auto-send it on mount.

**Add prop to interface (around line 10):**
```typescript
interface ChatInterfaceProps {
  conversationId?: string
  initialMessages?: Message[]
  initialPrompt?: string
}
```

**Destructure in component:**
```typescript
export function ChatInterface({
  conversationId,
  initialMessages = [],
  initialPrompt,
}: ChatInterfaceProps) {
```

**Add useEffect to auto-send prompt:**
```typescript
// Auto-send initial prompt (e.g., from sample prompt click)
useEffect(() => {
  if (initialPrompt && messages.length === 0) {
    console.log('[ChatInterface] Auto-sending initial prompt:', initialPrompt)
    sendMessage({ role: 'user', content: initialPrompt })
  }
}, [initialPrompt, messages.length, sendMessage])
```

**Why this works:** When component mounts with initialPrompt and no existing messages, automatically sends prompt as first user message. Triggers AI response immediately. Only runs once (messages.length check prevents re-sending).

**Dependencies explained:**
- `initialPrompt`: Re-run if prompt changes (shouldn't happen, but safe)
- `messages.length`: Only send if no messages yet (prevents duplicate sends)
- `sendMessage`: Required for linter, stable reference from useChat

**Alternative considered:** Pre-populate input field instead of auto-send. Rejected because sample prompts suggest immediate action - user expects AI to start working on the prompt immediately, not require extra click to send.
  </action>
  <verify>grep -n "initialPrompt" components/chat/chat-interface.tsx && grep -n "Auto-sending initial prompt" components/chat/chat-interface.tsx</verify>
  <done>ChatInterface accepts initialPrompt prop and auto-sends it on mount when no messages exist. User sees prompt sent and AI response starts streaming.</done>
</task>

</tasks>

<verification>
1. Start with no conversations (or navigate to empty state)
2. Click sample prompt "Explain quantum computing in simple terms"
3. Verify: New conversation created, prompt sent as first user message, AI response streams in
4. Check URL shows conversation ID (prompt query param consumed and not needed after send)
5. Click different sample prompt - another new conversation created with that prompt sent
6. Verify sample prompts work from conversation-list empty state
7. Build passes without TypeScript errors
</verification>

<success_criteria>
- Sample prompts create conversation and auto-send prompt text
- User sees their selected prompt as first user message
- AI response starts streaming immediately after prompt sends
- No error toasts (Plan 10's redirect error handling still works)
- Works for all sample prompts in empty state
- TypeScript compilation passes with new prop types
</success_criteria>

<output>
After completion, create `.planning/phases/01-chat-foundation-authentication/01-13-SUMMARY.md`
</output>
