---
phase: 01-chat-foundation-authentication
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/(auth)/auth.ts
  - app/(auth)/login/page.tsx
  - app/(auth)/register/page.tsx
  - app/api/auth/[...nextauth]/route.ts
  - middleware.ts
  - lib/db/queries.ts
  - lib/auth.ts
autonomous: true

user_setup:
  - service: postgresql
    why: "Database for storing user accounts and chat data"
    env_vars:
      - name: DATABASE_URL
        source: "PostgreSQL connection string (local or hosted like Neon, Supabase, Vercel Postgres)"
      - name: AUTH_SECRET
        source: "Generate with: openssl rand -base64 32"
    dashboard_config:
      - task: "Create PostgreSQL database"
        location: "Local (brew install postgresql) or hosted provider (Neon, Supabase, Vercel)"

must_haves:
  truths:
    - "User can create account with email and password"
    - "User can log in with credentials"
    - "User session persists across browser sessions"
    - "Invalid credentials return error message"
  artifacts:
    - path: "app/(auth)/auth.ts"
      provides: "NextAuth configuration with credentials provider"
      exports: ["auth", "signIn", "signOut", "handlers"]
      min_lines: 40
    - path: "app/(auth)/login/page.tsx"
      provides: "Login form UI"
      min_lines: 50
    - path: "app/(auth)/register/page.tsx"
      provides: "Registration form UI"
      min_lines: 60
    - path: "lib/db/queries.ts"
      provides: "Database query functions"
      exports: ["getUserByEmail", "createUser"]
  key_links:
    - from: "app/(auth)/auth.ts"
      to: "lib/db/queries.ts"
      via: "getUserByEmail call"
      pattern: "getUserByEmail.*email"
    - from: "app/(auth)/register/page.tsx"
      to: "app/(auth)/auth.ts"
      via: "signIn after registration"
      pattern: "signIn.*credentials"
    - from: "middleware.ts"
      to: "app/(auth)/auth.ts"
      via: "auth middleware export"
      pattern: "export.*auth.*middleware"
---

<objective>
Implement secure authentication system using NextAuth v5 with credentials provider, bcrypt password hashing, and session management. Create login and registration pages with form validation and error handling.

Purpose: Enable user accounts (AUTH-01, AUTH-02) and session persistence (AUTH-03) so that conversations and messages can be isolated per user (AUTH-04).

Output: Working authentication system where users can register, login, logout, and maintain sessions across browser restarts.
</objective>

<execution_context>
@/Users/christian.baverstock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/christian.baverstock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/christian.baverstock/code/ai-chat/.planning/PROJECT.md
@/Users/christian.baverstock/code/ai-chat/.planning/ROADMAP.md
@/Users/christian.baverstock/code/ai-chat/.planning/phases/01-chat-foundation-authentication/01-CONTEXT.md
@/Users/christian.baverstock/code/ai-chat/.planning/phases/01-chat-foundation-authentication/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Set up NextAuth with credentials provider and bcrypt</name>
  <files>
app/(auth)/auth.ts
app/api/auth/[...nextauth]/route.ts
middleware.ts
lib/db/queries.ts
lib/auth.ts
  </files>
  <action>
Implement NextAuth v5 configuration following research Pattern 5:

**lib/db/queries.ts:**
Create database query functions:
- `getUserByEmail(email: string)` - fetch user by email with password hash
- `createUser(email: string, password: string)` - create new user with bcrypt-hashed password (10 rounds)
- `getUserById(id: string)` - fetch user by id for session

Use Drizzle ORM with the schema from plan 01. All queries must use parameterized queries to prevent SQL injection.

**app/(auth)/auth.ts:**
Configure NextAuth with:
- Credentials provider accepting email and password
- `authorize` callback that:
  1. Calls getUserByEmail
  2. Uses bcrypt-ts `compare()` to verify password
  3. Returns user object with id and email on success, null on failure
- JWT callback to add user.id to token
- Session callback to add token.id to session.user
- Pages config pointing to custom /login route
- Session strategy: "jwt"
- Cookie settings: secure in production, httpOnly always

**app/api/auth/[...nextauth]/route.ts:**
Export GET and POST handlers from auth.ts

**middleware.ts:**
Export auth as middleware with matcher protecting all routes except:
- /api/auth/* (auth endpoints)
- /_next/static/* (static files)
- /_next/image/* (images)
- /favicon.ico
- /login
- /register

Per research, this prevents auth bypass via URL manipulation (Pitfall 2).

**lib/auth.ts:**
Helper functions for auth checks and password hashing utilities.

Use bcrypt-ts (not native bcrypt) for Edge Runtime compatibility per research.
  </action>
  <verify>
1. Run `npm run dev` without auth errors
2. Check middleware.ts exports auth correctly
3. Verify app/(auth)/auth.ts has authorize callback with bcrypt compare
4. Check lib/db/queries.ts uses Drizzle parameterized queries
  </verify>
  <done>
NextAuth configured with credentials provider, bcrypt password hashing, JWT sessions, and middleware protecting routes. Database queries ready for user operations.
  </done>
</task>

<task type="auto">
  <name>Create login and registration pages</name>
  <files>
app/(auth)/login/page.tsx
app/(auth)/register/page.tsx
app/(auth)/layout.tsx
components/auth/auth-form.tsx
  </files>
  <action>
Create authentication UI with form validation and error handling:

**app/(auth)/layout.tsx:**
Simple centered layout for auth pages with minimal styling. No sidebar or navigation.

**components/auth/auth-form.tsx:**
Reusable form component with:
- Email input (type="email", required)
- Password input (type="password", required, min 8 characters)
- Submit button with loading state
- Error message display area
- Client-side validation before submit
- Toast notification on errors using sonner

**app/(auth)/register/page.tsx:**
Registration page that:
1. Renders AuthForm with "Register" mode
2. Validates email format and password length (min 8 chars)
3. Checks password confirmation match
4. Calls createUser from lib/db/queries
5. Signs in user automatically after successful registration
6. Redirects to / on success
7. Shows specific error messages:
   - "Email already exists" if duplicate
   - "Password must be at least 8 characters"
   - "Passwords do not match"

**app/(auth)/login/page.tsx:**
Login page that:
1. Renders AuthForm with "Login" mode
2. Validates email format
3. Calls signIn from app/(auth)/auth.ts
4. Redirects to / on success
5. Shows error message: "Invalid email or password" on failure

Use Tailwind CSS for styling - professional, clean aesthetic per user decisions. No clutter.

Forms should be accessible (proper labels, error announcements, keyboard navigation).
  </action>
  <verify>
1. Visit http://localhost:3000/register - form renders correctly
2. Visit http://localhost:3000/login - form renders correctly
3. Check forms have proper HTML validation attributes
4. Verify error states are handled with sonner toasts
5. Check password input has type="password" (masked)
  </verify>
  <done>
Login and registration pages created with form validation, error handling, and clean UI. Forms are accessible and follow user's professional aesthetic requirement.
  </done>
</task>

<task type="auto">
  <name>Apply database migrations and test authentication flow</name>
  <files>
package.json (add migration script)
  </files>
  <action>
Set up database migration workflow:

1. Add npm scripts to package.json:
   - "db:generate": "drizzle-kit generate"
   - "db:migrate": "drizzle-kit migrate"
   - "db:push": "drizzle-kit push"
   - "db:studio": "drizzle-kit studio"

2. Create instructions in .env.local.example for required environment variables:
   - DATABASE_URL (PostgreSQL connection string)
   - AUTH_SECRET (openssl rand -base64 32)

3. Run `npm run db:push` to apply schema to database (once DATABASE_URL is provided)

4. Test authentication flow:
   - Start dev server
   - Visit /register
   - Create test account
   - Verify redirect to / (chat interface)
   - Logout
   - Login with same credentials
   - Verify session persists across page refresh

Note: Actual database setup is in user_setup frontmatter - user must provide DATABASE_URL and AUTH_SECRET before running migrations.
  </action>
  <verify>
1. Check package.json has db:* scripts
2. Run `npm run db:generate` successfully
3. Verify .env.local.example documents required variables
4. If DATABASE_URL exists, run `npm run db:push` and verify tables created
  </verify>
  <done>
Database migration workflow configured. If database credentials provided, schema applied successfully. Authentication flow tested and working.
  </done>
</task>

</tasks>

<verification>
1. Visit http://localhost:3000/register and create account
2. Verify password is hashed in database (not plaintext)
3. Logout and login with same credentials - succeeds
4. Try login with wrong password - shows error
5. Refresh page after login - session persists (still logged in)
6. Middleware protects routes - visiting / when logged out redirects to /login
</verification>

<success_criteria>
- User can create account with email and password (AUTH-01)
- User can login with credentials (AUTH-02)
- Session persists across browser sessions (AUTH-03)
- Protected routes redirect to login when unauthenticated
- Password stored as bcrypt hash (not plaintext)
- Forms show appropriate error messages for validation failures
</success_criteria>

<output>
After completion, create `.planning/phases/01-chat-foundation-authentication/01-02-SUMMARY.md` documenting:
- NextAuth configuration choices (JWT vs database sessions, cookie settings)
- Password requirements and validation rules
- Error handling approach
- Middleware protection strategy
- Any security considerations
</output>
