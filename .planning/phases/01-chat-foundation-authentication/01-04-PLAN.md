---
phase: 01-chat-foundation-authentication
plan: 04
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - app/(chat)/page.tsx
  - app/(chat)/layout.tsx
  - components/chat/chat-interface.tsx
  - components/chat/message-list.tsx
  - components/chat/message.tsx
  - components/chat/message-input.tsx
  - components/chat/streaming-response.tsx
  - components/chat/typing-indicator.tsx
  - components/ui/avatar.tsx
  - components/ui/scroll-area.tsx
  - lib/utils.ts
autonomous: true

must_haves:
  truths:
    - "User can see message history in conversation bubbles"
    - "User messages appear right-aligned with distinct color"
    - "AI messages appear left-aligned with different color"
    - "Both user and AI messages show avatars"
    - "Typing indicator shows before AI response streams"
    - "AI response streams word-by-word"
    - "Markdown renders correctly in AI responses"
    - "Code blocks display with syntax highlighting and copy button"
    - "Timestamps display on messages"
    - "Message actions (copy, edit, delete) appear on hover"
  artifacts:
    - path: "components/chat/chat-interface.tsx"
      provides: "Main chat container using useChat hook"
      min_lines: 80
    - path: "components/chat/message-list.tsx"
      provides: "Scrollable message area"
      min_lines: 50
    - path: "components/chat/message.tsx"
      provides: "Individual message component with avatar and metadata"
      min_lines: 100
    - path: "components/chat/streaming-response.tsx"
      provides: "Markdown renderer with Streamdown"
      min_lines: 30
    - path: "components/chat/message-input.tsx"
      provides: "Fixed bottom input field"
      min_lines: 60
  key_links:
    - from: "components/chat/chat-interface.tsx"
      to: "@ai-sdk/react"
      via: "useChat hook"
      pattern: "useChat.*api.*onFinish"
    - from: "components/chat/message.tsx"
      to: "components/chat/streaming-response.tsx"
      via: "render AI message content"
      pattern: "StreamingResponse.*content"
    - from: "components/chat/streaming-response.tsx"
      to: "streamdown"
      via: "Streamdown component"
      pattern: "Streamdown.*children"
---

<objective>
Build the main chat UI with message display, streaming responses, markdown rendering, and code syntax highlighting. Implement user decisions: color + alignment distinction, avatars, typing indicator, timestamps, hover actions.

Purpose: Deliver visual chat interface (CHAT-02) with streaming (CHAT-01), markdown (CHAT-03), and code rendering (CHAT-04).

Output: Complete chat interface matching user's design decisions - professional, clean, with streaming AI responses.
</objective>

<execution_context>
@/Users/christian.baverstock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/christian.baverstock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/christian.baverstock/code/ai-chat/.planning/PROJECT.md
@/Users/christian.baverstock/code/ai-chat/.planning/ROADMAP.md
@/Users/christian.baverstock/code/ai-chat/.planning/phases/01-chat-foundation-authentication/01-CONTEXT.md
@/Users/christian.baverstock/code/ai-chat/.planning/phases/01-chat-foundation-authentication/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Create chat interface with useChat hook</name>
  <files>
app/(chat)/page.tsx
app/(chat)/layout.tsx
components/chat/chat-interface.tsx
components/chat/message-input.tsx
components/chat/typing-indicator.tsx
lib/utils.ts
  </files>
  <action>
Build main chat interface following research Pattern 2:

**app/(chat)/layout.tsx:**
Protected layout that:
- Checks authentication with `await auth()` server-side
- Redirects to /login if not authenticated
- Renders children (chat interface)
- Simple wrapper, no sidebar yet (that's plan 05)

**components/chat/chat-interface.tsx:**
Main client component using useChat hook:
```typescript
'use client';
import { useChat } from '@ai-sdk/react';

export function ChatInterface({ conversationId }: { conversationId?: string }) {
  const { messages, sendMessage, status, stop } = useChat({
    api: '/api/chat',
    body: { conversationId },
    onFinish: (message) => {
      // Message already saved by API route
      // Could refresh conversation list here (plan 05)
    },
  });

  return (
    <div className="flex flex-col h-screen">
      <MessageList messages={messages} status={status} />
      <MessageInput onSend={sendMessage} disabled={status === 'streaming'} />
    </div>
  );
}
```

**components/chat/message-input.tsx:**
Fixed bottom input following user decision "Input positioning: Fixed at bottom of screen, always visible":
- textarea with auto-resize (grow up to max height)
- Send button (disabled while streaming)
- Keyboard shortcut: Enter to send, Shift+Enter for new line
- Clear after send
- Focus on mount
- Loading state during streaming

Style with Tailwind - clean, professional. Input stays at bottom, messages scroll above.

**components/chat/typing-indicator.tsx:**
Simple "AI is typing..." indicator with animated dots. Show when status === 'streaming' and no AI response yet.

**lib/utils.ts:**
Utility functions:
- `cn()` - classnames utility for Tailwind (clsx + tailwind-merge)
- Date formatting helpers using date-fns
  </action>
  <verify>
1. Run `npm run dev` and visit http://localhost:3000
2. Check page redirects to /login if not authenticated
3. After login, verify chat interface renders
4. Check message input is fixed at bottom
5. Verify TypeScript compiles without errors
  </verify>
  <done>
Chat interface created with useChat hook, fixed bottom input, typing indicator, and authentication protection. Layout structure ready for message display.
  </done>
</task>

<task type="auto">
  <name>Implement message display with avatars and styling</name>
  <files>
components/chat/message-list.tsx
components/chat/message.tsx
components/ui/avatar.tsx
components/ui/scroll-area.tsx
  </files>
  <action>
Create message display components following user decisions:

**components/ui/scroll-area.tsx:**
Wrapper around @radix-ui/react-scroll-area for styled scrolling in message list.

**components/ui/avatar.tsx:**
Wrapper around @radix-ui/react-avatar:
- User avatar: shows user initials or icon
- AI avatar: shows AI icon or "AI" text
- Fallback to initials if no image

**components/chat/message-list.tsx:**
Scrollable message container:
- Uses ScrollArea component
- Auto-scrolls to bottom on new messages
- Handles empty state (no messages yet)
- Groups messages by time threshold (5 minutes - use discretion per user decision)
- Renders typing indicator when status === 'streaming'

**components/chat/message.tsx:**
Individual message component implementing ALL user decisions:

**Visual distinction (user decision):**
- User messages: right-aligned, one background color (e.g., blue-500)
- AI messages: left-aligned, different color (e.g., gray-100)

**Avatars (user decision):**
- Show avatar next to each message
- User avatar on right for user messages
- AI avatar on left for AI messages

**Message metadata (user decision):**
- Show timestamp using date-fns (format as relative time like "2 minutes ago")
- Message actions on hover: copy button, edit button (placeholder), delete button (placeholder)
- Keep minimal - only essential info

**Message grouping (user decision):**
- Consecutive messages from same sender within 5 minutes appear as one group
- Only show avatar and timestamp on first message in group

Layout structure per message role:
```
User message:
[Message content] [Avatar]

AI message:
[Avatar] [Message content]
```

Use Tailwind for styling - professional and clean per user requirements.
  </action>
  <verify>
1. Send test message and verify it appears right-aligned
2. Check user message has distinct background color
3. Verify avatar appears next to message
4. Check timestamp displays
5. Hover over message - actions should appear
  </verify>
  <done>
Message display components created with proper alignment, colors, avatars, timestamps, and hover actions. Message grouping implemented with time threshold.
  </done>
</task>

<task type="auto">
  <name>Add markdown and code rendering with syntax highlighting</name>
  <files>
components/chat/streaming-response.tsx
components/ui/code-block.tsx
lib/shiki-config.ts
  </files>
  <action>
Implement markdown and code rendering following user decisions and research Pattern 6:

**lib/shiki-config.ts:**
Configure Shiki for syntax highlighting:
- Load common language grammars (typescript, javascript, python, bash, etc.)
- Set theme (VS Code Dark Plus for dark mode, Light Plus for light)
- Configure for streaming use

**components/ui/code-block.tsx:**
Code block component with:
- Syntax highlighting using Shiki
- Copy button in top-right corner (user decision: "copy button - full language detection and one-click copy")
- Language label display
- One-click copy with sonner toast feedback ("Copied!")
- Line numbers optional

**components/chat/streaming-response.tsx:**
Streamdown wrapper for AI responses:
```typescript
'use client';
import { Streamdown } from 'streamdown';
import { CodeBlock } from '@/components/ui/code-block';

export function StreamingResponse({ content }: { content: string }) {
  return (
    <Streamdown
      className="prose dark:prose-invert max-w-none"
      components={{
        code: CodeBlock, // Use custom code block component
      }}
    >
      {content}
    </Streamdown>
  );
}
```

Per user decision: "Full Markdown - headers, lists, tables, links, images, blockquotes"
Streamdown handles this automatically.

Per research: "Don't use regular markdown parsers for streaming" - Streamdown handles incomplete markdown during streaming.

Update Message component to use StreamingResponse for AI message content.
  </action>
  <verify>
1. Send message asking for code example
2. Verify code block renders with syntax highlighting
3. Check copy button appears in top-right of code block
4. Click copy button - should show success toast
5. Test markdown: send message asking for "list of 3 items with **bold** and *italic*"
6. Verify markdown renders correctly (bold, italic, list)
  </verify>
  <done>
Markdown and code rendering implemented with Streamdown and Shiki. Code blocks have syntax highlighting and copy buttons. Full markdown support working.
  </done>
</task>

</tasks>

<verification>
1. Send message "Hello" - appears right-aligned with user avatar and timestamp
2. AI response streams word-by-word on left side with AI avatar
3. Hover over messages - action buttons appear
4. Send message asking for code - renders with syntax highlighting and copy button
5. Send message with **bold** and *italic* - markdown renders correctly
6. Check responsive behavior - messages readable on narrow screens
7. Verify typing indicator shows before AI response starts
</verification>

<success_criteria>
- User can see conversation history in message bubbles (CHAT-02)
- AI responses render markdown correctly (CHAT-03)
- Code blocks display with syntax highlighting and copy button (CHAT-04)
- Messages distinguished by color AND alignment per user decision
- Avatars shown for both user and AI per user decision
- Typing indicator then word-by-word streaming per user decision
- Timestamps and message actions on hover per user decision
- Professional, clean aesthetic per user requirement
</success_criteria>

<output>
After completion, create `.planning/phases/01-chat-foundation-authentication/01-04-SUMMARY.md` documenting:
- Message layout and styling choices (colors, alignment, spacing)
- Markdown rendering approach (Streamdown configuration)
- Syntax highlighting setup (Shiki languages and themes)
- Message grouping threshold chosen (5 minutes)
- Responsive behavior decisions
- Any UX enhancements beyond requirements
</output>
