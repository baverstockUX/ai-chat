---
phase: 05-resources-management-and-sharing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/(chat)/actions.ts
  - lib/uploads/.gitkeep
  - public/uploads/images/.gitkeep
autonomous: true

must_haves:
  truths:
    - "User can upload image file through Server Action"
    - "Image files stored in filesystem with unique filenames"
    - "Upload validates file type and size"
  artifacts:
    - path: "app/(chat)/actions.ts"
      provides: "uploadImage Server Action"
      exports: ["uploadImage"]
      min_lines: 50
    - path: "public/uploads/images"
      provides: "Image storage directory"
  key_links:
    - from: "uploadImage Server Action"
      to: "filesystem"
      via: "fs/promises writeFile"
      pattern: "writeFile.*public/uploads"
    - from: "client"
      to: "uploadImage"
      via: "FormData submission"
      pattern: "FormData.*append.*image"
---

<objective>
Implement image upload infrastructure using Next.js Server Actions and filesystem storage, enabling users to attach images to chat messages.

Purpose: Establish multimodal input capability with secure file handling, type validation, and public URL generation. Uses research Pattern 5 (Server Actions + FormData).

Output: Image upload Server Action with validation, filesystem storage directory, and public URL mapping.
</objective>

<execution_context>
@/Users/christian.baverstock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/christian.baverstock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-resources-management-and-sharing/05-RESEARCH.md
@.planning/phases/01-chat-foundation-authentication/01-05-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create image upload Server Action</name>
  <files>app/(chat)/actions.ts</files>
  <action>
Add uploadImage Server Action to app/(chat)/actions.ts following research Pattern 5:

```typescript
'use server';

import { auth } from '@/app/(auth)/auth';
import { writeFile, mkdir } from 'fs/promises';
import { join } from 'path';
import { nanoid } from 'nanoid';

interface UploadImageResult {
  success: boolean;
  imageUrl?: string;
  error?: string;
}

export async function uploadImage(formData: FormData): Promise<UploadImageResult> {
  // 1. Auth guard
  const session = await auth();
  if (!session?.user?.id) {
    return { success: false, error: 'Unauthorized' };
  }

  // 2. Extract file from FormData
  const file = formData.get('image') as File;
  if (!file) {
    return { success: false, error: 'No file provided' };
  }

  // 3. Validate file type
  const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
  if (!allowedTypes.includes(file.type)) {
    return { success: false, error: 'Invalid file type. Allowed: JPEG, PNG, GIF, WebP' };
  }

  // 4. Validate file size (max 10MB)
  const maxSize = 10 * 1024 * 1024; // 10MB
  if (file.size > maxSize) {
    return { success: false, error: 'File too large. Maximum size: 10MB' };
  }

  try {
    // 5. Generate unique filename with nanoid
    const extension = file.name.split('.').pop();
    const filename = `${nanoid()}.${extension}`;

    // 6. Create upload directory if doesn't exist
    const uploadDir = join(process.cwd(), 'public', 'uploads', 'images');
    await mkdir(uploadDir, { recursive: true });

    // 7. Convert file to buffer and write to filesystem
    const bytes = await file.arrayBuffer();
    const buffer = Buffer.from(bytes);
    const filePath = join(uploadDir, filename);
    await writeFile(filePath, buffer);

    // 8. Return public URL
    const imageUrl = `/uploads/images/${filename}`;
    return { success: true, imageUrl };
  } catch (error) {
    console.error('Image upload error:', error);
    return { success: false, error: 'Failed to upload image' };
  }
}
```

Uses nanoid (already installed), fs/promises (async), follows Phase 1 auth guard pattern.
  </action>
  <verify>
grep -A 50 "export async function uploadImage" app/(chat)/actions.ts
grep "nanoid" app/(chat)/actions.ts
  </verify>
  <done>uploadImage Server Action implemented with validation, auth guard, and filesystem storage</done>
</task>

<task type="auto">
  <name>Task 2: Create upload directories</name>
  <files>lib/uploads/.gitkeep, public/uploads/images/.gitkeep</files>
  <action>
Create directory structure for uploads:

1. Create public/uploads/images directory (for web-accessible images)
2. Add .gitkeep files to ensure directories tracked in git
3. Add public/uploads/ to .gitignore to prevent committing uploaded files

Structure:
```
public/
  uploads/
    images/       # Images served via /uploads/images/[filename]
      .gitkeep    # Track directory, ignore contents
```

The mkdir({ recursive: true }) in uploadImage will create these at runtime, but .gitkeep ensures they exist in repo.

Add to .gitignore:
```
# Uploaded files
public/uploads/*
!public/uploads/.gitkeep
!public/uploads/images/.gitkeep
```
  </action>
  <verify>
ls -la public/uploads/images/.gitkeep
grep "public/uploads" .gitignore
  </verify>
  <done>Upload directories created with .gitkeep, .gitignore configured to exclude uploaded files</done>
</task>

<task type="auto">
  <name>Task 3: Test image upload flow</name>
  <files>app/(chat)/actions.ts</files>
  <action>
Verify upload infrastructure works end-to-end:

1. Create test script or use curl to test uploadImage:
```bash
# Create test image (1x1 transparent PNG)
echo "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==" | base64 -d > /tmp/test.png

# Test upload (requires auth session - document for human testing)
echo "Test image upload by uploading /tmp/test.png through UI"
```

2. Verify:
- File appears in public/uploads/images/ with nanoid filename
- Returned imageUrl is accessible: http://localhost:3000/uploads/images/[filename]
- File size validation works (try >10MB file, should reject)
- File type validation works (try .txt file, should reject)

3. Document test results in commit message

Note: Cannot test programmatically without auth session. Human verification in Phase 5 checkpoint will validate full flow.
  </action>
  <verify>
ls public/uploads/images/ | wc -l
# Manual test: Upload image through UI and verify file exists
  </verify>
  <done>Upload infrastructure tested, filesystem storage working, validation rules verified</done>
</task>

</tasks>

<verification>
**Server Action verification:**
- [ ] uploadImage exported from app/(chat)/actions.ts
- [ ] Auth guard checks session.user.id
- [ ] File type validation accepts JPEG, PNG, GIF, WebP only
- [ ] File size validation rejects files >10MB
- [ ] Filename generated with nanoid for uniqueness

**Filesystem verification:**
- [ ] public/uploads/images directory exists
- [ ] Directory has .gitkeep for git tracking
- [ ] .gitignore excludes public/uploads/* except .gitkeep files
- [ ] mkdir recursive: true ensures directory created at runtime

**Integration verification:**
- [ ] Uploaded file accessible at /uploads/images/[filename]
- [ ] Multiple uploads don't collide (nanoid uniqueness)
</verification>

<success_criteria>
1. User calls uploadImage with valid image → file saved to public/uploads/images → imageUrl returned
2. User tries to upload 15MB image → rejected with "File too large" error
3. User tries to upload .txt file → rejected with "Invalid file type" error
4. Uploaded image accessible at http://localhost:3000/uploads/images/[nanoid].[ext]
5. Two simultaneous uploads generate unique filenames (no collisions)
</success_criteria>

<output>
After completion, create `.planning/phases/05-resources-management-and-sharing/05-02-SUMMARY.md`
</output>
