---
phase: 05-resources-management-and-sharing
plan: 03
type: execute
wave: 2
depends_on: [05-01]
files_modified:
  - app/(chat)/actions.ts
  - components/resources/resource-browser.tsx
  - components/resources/resource-card.tsx
  - components/resources/save-resource-dialog.tsx
  - components/chat/message-actions.tsx
  - app/(chat)/resources/page.tsx
  - app/api/resources/route.ts
  - app/api/resources/[id]/route.ts
autonomous: true

must_haves:
  truths:
    - "User can save successful agent workflow as Resource"
    - "User provides name and description when saving Resource"
    - "User can browse saved Resources in workspace"
    - "User can search and filter Resources by name/type"
    - "User can preview Resource content before executing"
  artifacts:
    - path: "app/(chat)/actions.ts"
      provides: "saveAsResource Server Action"
      exports: ["saveAsResource"]
    - path: "components/resources/resource-browser.tsx"
      provides: "Resource list and search UI"
      min_lines: 100
    - path: "app/(chat)/resources/page.tsx"
      provides: "Resources page route"
  key_links:
    - from: "SaveResourceDialog"
      to: "saveAsResource"
      via: "Server Action call"
      pattern: "await saveAsResource"
    - from: "ResourceBrowser"
      to: "/api/resources"
      via: "fetch for resource list"
      pattern: "fetch.*api/resources"
---

<objective>
Enable users to save successful agent workflows as reusable Resources with name/description, browse their saved Resources with search/filter, and preview Resource details.

Purpose: Implement core resource management UX (RES-01 through RES-06) allowing users to capture and organize workflows. Follows Phase 1 Server Actions and Phase 2 JSONB patterns.

Output: Save dialog, resource browser with search, resource cards, and resources page route.
</objective>

<execution_context>
@/Users/christian.baverstock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/christian.baverstock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-resources-management-and-sharing/05-RESEARCH.md
@.planning/phases/05-resources-management-and-sharing/05-01-SUMMARY.md
@.planning/phases/02-ai-orchestration-intent-detection/02-03-SUMMARY.md
@.planning/phases/01-chat-foundation-authentication/01-05-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create saveAsResource Server Action</name>
  <files>app/(chat)/actions.ts</files>
  <action>
Add saveAsResource Server Action to app/(chat)/actions.ts following research Pattern 2:

```typescript
'use server';

import { auth } from '@/app/(auth)/auth';
import { db } from '@/lib/db';
import { resource, message } from '@/lib/db/schema';
import { createResource } from '@/lib/db/queries';
import { eq, or, and, asc } from 'drizzle-orm';
import { revalidatePath } from 'next/cache';

interface SaveResourceInput {
  conversationId: string;
  messageId: string; // Agent result message
  name: string;
  description?: string;
  resourceType: 'workflow' | 'prompt' | 'agent_config';
}

export async function saveAsResource(input: SaveResourceInput) {
  const session = await auth();
  if (!session?.user?.id) throw new Error('Unauthorized');

  // Validate name
  if (input.name.length < 1 || input.name.length > 255) {
    throw new Error('Name must be 1-255 characters');
  }

  // Fetch agent execution history from messages
  const messages = await db
    .select()
    .from(message)
    .where(
      and(
        eq(message.conversationId, input.conversationId),
        or(
          eq(message.messageType, 'agent_request'),
          eq(message.messageType, 'agent_progress'),
          eq(message.messageType, 'agent_result')
        )
      )
    )
    .orderBy(asc(message.createdAt));

  if (messages.length === 0) {
    throw new Error('No agent messages found for this conversation');
  }

  // Extract workflow content from messages
  const workflowContent = {
    version: 1, // Schema version for future migrations
    request: messages.find(m => m.messageType === 'agent_request')?.content,
    steps: messages
      .filter(m => m.messageType === 'agent_progress')
      .map(m => ({
        timestamp: m.createdAt,
        content: m.content,
        metadata: m.metadata,
      })),
    result: messages.find(m => m.messageType === 'agent_result')?.content,
    metadata: {
      conversationId: input.conversationId,
      messageId: input.messageId,
      capturedAt: new Date().toISOString(),
    },
  };

  // Create resource using query function
  const newResource = await createResource({
    userId: session.user.id,
    name: input.name,
    description: input.description,
    resourceType: input.resourceType,
    content: workflowContent,
  });

  revalidatePath('/resources');
  return { success: true, resourceId: newResource.id };
}
```

Captures agent_request, agent_progress, agent_result messages into JSONB content field with schema version.
  </action>
  <verify>
grep -A 60 "export async function saveAsResource" app/(chat)/actions.ts
grep "version: 1" app/(chat)/actions.ts
  </verify>
  <done>saveAsResource Server Action implemented with message extraction and schema versioning</done>
</task>

<task type="auto">
  <name>Task 2: Create Save Resource dialog and message action</name>
  <files>components/resources/save-resource-dialog.tsx, components/chat/message-actions.tsx</files>
  <action>
1. Create SaveResourceDialog component following research code example and Phase 2 dialog pattern:

components/resources/save-resource-dialog.tsx:
```typescript
'use client';

import { useState } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { saveAsResource } from '@/app/(chat)/actions';
import { toast } from 'sonner';

interface SaveResourceDialogProps {
  conversationId: string;
  messageId: string;
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export function SaveResourceDialog(props: SaveResourceDialogProps) {
  const [name, setName] = useState('');
  const [description, setDescription] = useState('');
  const [saving, setSaving] = useState(false);

  const handleSave = async () => {
    if (!name.trim()) {
      toast.error('Please enter a name');
      return;
    }

    setSaving(true);
    try {
      const result = await saveAsResource({
        conversationId: props.conversationId,
        messageId: props.messageId,
        name,
        description,
        resourceType: 'workflow',
      });

      if (result.success) {
        toast.success('Resource saved successfully');
        props.onOpenChange(false);
        setName('');
        setDescription('');
      }
    } catch (error) {
      console.error('Failed to save resource:', error);
      toast.error(error instanceof Error ? error.message : 'Failed to save resource');
    } finally {
      setSaving(false);
    }
  };

  return (
    <Dialog open={props.open} onOpenChange={props.onOpenChange}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Save as Resource</DialogTitle>
        </DialogHeader>
        <div className="space-y-4">
          <div>
            <label className="text-sm font-medium">Name</label>
            <Input
              value={name}
              onChange={(e) => setName(e.target.value)}
              placeholder="My Workflow"
              className="mt-1"
            />
          </div>
          <div>
            <label className="text-sm font-medium">Description (optional)</label>
            <Textarea
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              placeholder="Describe what this workflow does..."
              rows={3}
              className="mt-1"
            />
          </div>
          <div className="flex gap-2 justify-end">
            <Button variant="outline" onClick={() => props.onOpenChange(false)}>
              Cancel
            </Button>
            <Button onClick={handleSave} disabled={!name.trim() || saving}>
              {saving ? 'Saving...' : 'Save Resource'}
            </Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}
```

2. Update components/chat/message-actions.tsx (if exists) or create message action trigger:
- Add "Save as Resource" button to agent_result messages
- Opens SaveResourceDialog on click
- Only show for successful agent executions

Uses existing Dialog, Button, Input, Textarea components from shadcn/ui.
  </action>
  <verify>
grep -A 50 "export function SaveResourceDialog" components/resources/save-resource-dialog.tsx
grep "SaveResourceDialog" components/chat/message-actions.tsx
  </verify>
  <done>SaveResourceDialog component created with validation, MessageActions updated to trigger dialog</done>
</task>

<task type="auto">
  <name>Task 3: Create GET and DELETE API routes for resources</name>
  <files>app/api/resources/route.ts, app/api/resources/[id]/route.ts</files>
  <action>
1. Create GET endpoint for resource list with search/filter (required by ResourceBrowser):

app/api/resources/route.ts:
```typescript
import { auth } from '@/app/(auth)/auth';
import { getUserResources } from '@/lib/db/queries';
import { NextResponse } from 'next/server';

export async function GET(req: Request) {
  const session = await auth();
  if (!session?.user?.id) {
    return new Response('Unauthorized', { status: 401 });
  }

  try {
    const { searchParams } = new URL(req.url);
    const search = searchParams.get('search') || undefined;
    const resourceType = searchParams.get('type') || undefined;

    const resources = await getUserResources(session.user.id, {
      search,
      resourceType: resourceType as 'workflow' | 'prompt' | 'agent_config' | undefined,
    });

    return NextResponse.json({ resources });
  } catch (error) {
    console.error('Get resources error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to fetch resources' },
      { status: 500 }
    );
  }
}
```

Uses getUserResources query function from Plan 05-01 with optional search and resourceType filters.

2. Create DELETE endpoint for resource deletion:

app/api/resources/[id]/route.ts:
```typescript
import { auth } from '@/app/(auth)/auth';
import { deleteResource } from '@/lib/db/queries';
import { NextResponse } from 'next/server';

export async function DELETE(
  req: Request,
  { params }: { params: { id: string } }
) {
  const session = await auth();
  if (!session?.user?.id) {
    return new Response('Unauthorized', { status: 401 });
  }

  try {
    await deleteResource(params.id, session.user.id);
    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Delete resource error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to delete resource' },
      { status: 500 }
    );
  }
}
```

Uses deleteResource query function from Plan 05-01, ensures user owns resource before deletion.
  </action>
  <verify>
grep -A 25 "export async function GET" app/api/resources/route.ts
grep "getUserResources" app/api/resources/route.ts
grep -A 20 "export async function DELETE" app/api/resources/\[id\]/route.ts
grep "deleteResource.*params.id" app/api/resources/\[id\]/route.ts
  </verify>
  <done>GET endpoint implemented with search/filter, DELETE endpoint implemented with auth check</done>
</task>

<task type="auto">
  <name>Task 4: Create Resource browser and resources page</name>
  <files>components/resources/resource-browser.tsx, components/resources/resource-card.tsx, app/(chat)/resources/page.tsx</files>
  <action>
1. Create ResourceBrowser component following research Pattern 7:

components/resources/resource-browser.tsx:
```typescript
'use client';

import { useState, useEffect } from 'react';
import { Input } from '@/components/ui/input';
import { ResourceCard } from './resource-card';
import type { Resource } from '@/lib/db/schema';

interface ResourceBrowserProps {
  userId: string;
}

export function ResourceBrowser({ userId }: ResourceBrowserProps) {
  const [resources, setResources] = useState<Resource[]>([]);
  const [searchQuery, setSearchQuery] = useState('');
  const [filterType, setFilterType] = useState<string>('');
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchResources();
  }, [searchQuery, filterType]);

  const fetchResources = async () => {
    setLoading(true);
    try {
      const params = new URLSearchParams();
      if (searchQuery) params.set('search', searchQuery);
      if (filterType) params.set('type', filterType);

      const response = await fetch(`/api/resources?${params}`);
      const data = await response.json();
      setResources(data.resources || []);
    } catch (error) {
      console.error('Failed to fetch resources:', error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="space-y-4">
      <div className="flex gap-2">
        <Input
          type="text"
          placeholder="Search resources..."
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
          className="flex-1"
        />
        <select
          value={filterType}
          onChange={(e) => setFilterType(e.target.value)}
          className="px-3 py-2 border rounded-md"
        >
          <option value="">All Types</option>
          <option value="workflow">Workflows</option>
          <option value="prompt">Prompts</option>
          <option value="agent_config">Agent Configs</option>
        </select>
      </div>

      {loading ? (
        <div className="text-center py-8 text-muted-foreground">Loading resources...</div>
      ) : resources.length === 0 ? (
        <div className="text-center py-8 text-muted-foreground">
          No resources found. Save your first workflow to get started.
        </div>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {resources.map((resource) => (
            <ResourceCard key={resource.id} resource={resource} onUpdate={fetchResources} />
          ))}
        </div>
      )}
    </div>
  );
}
```

2. Create ResourceCard component:

components/resources/resource-card.tsx:
```typescript
'use client';

import { Card, CardHeader, CardTitle, CardContent, CardFooter } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import type { Resource } from '@/lib/db/schema';
import { formatDistance } from 'date-fns';

interface ResourceCardProps {
  resource: Resource;
  onUpdate: () => void;
}

export function ResourceCard({ resource, onUpdate }: ResourceCardProps) {
  const handleExecute = async () => {
    // Execute workflow (implement in Phase 5 Plan 5)
    console.log('Execute resource:', resource.id);
  };

  const handleDelete = async () => {
    if (!confirm(`Delete "${resource.name}"?`)) return;

    try {
      const response = await fetch(`/api/resources/${resource.id}`, {
        method: 'DELETE',
      });

      if (response.ok) {
        onUpdate();
      }
    } catch (error) {
      console.error('Failed to delete resource:', error);
    }
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle className="text-lg">{resource.name}</CardTitle>
        <p className="text-xs text-muted-foreground">
          {resource.resourceType} · {formatDistance(new Date(resource.createdAt), new Date(), { addSuffix: true })}
        </p>
      </CardHeader>
      <CardContent>
        <p className="text-sm text-muted-foreground line-clamp-3">
          {resource.description || 'No description'}
        </p>
        {resource.parentResourceId && (
          <p className="text-xs text-muted-foreground mt-2">
            Forked from original
          </p>
        )}
      </CardContent>
      <CardFooter className="flex gap-2">
        <Button onClick={handleExecute} size="sm">
          Execute
        </Button>
        <Button variant="outline" size="sm" onClick={handleDelete}>
          Delete
        </Button>
      </CardFooter>
    </Card>
  );
}
```

3. Create resources page:

app/(chat)/resources/page.tsx:
```typescript
import { auth } from '@/app/(auth)/auth';
import { redirect } from 'next/navigation';
import { ResourceBrowser } from '@/components/resources/resource-browser';

export default async function ResourcesPage() {
  const session = await auth();

  if (!session?.user?.id) {
    redirect('/login');
  }

  return (
    <div className="container mx-auto py-8">
      <div className="mb-6">
        <h1 className="text-3xl font-bold">Resources</h1>
        <p className="text-muted-foreground mt-2">
          Saved workflows and templates you can reuse
        </p>
      </div>

      <ResourceBrowser userId={session.user.id} />
    </div>
  );
}
```

Uses existing Card, Button, Input components. Requires date-fns (check if installed, add if not: npm install date-fns).
  </action>
  <verify>
grep -A 50 "export function ResourceBrowser" components/resources/resource-browser.tsx
grep -A 40 "export function ResourceCard" components/resources/resource-card.tsx
grep "ResourceBrowser" app/(chat)/resources/page.tsx
  </verify>
  <done>ResourceBrowser with search/filter, ResourceCard with actions, resources page route created</done>
</task>

</tasks>

<verification>
**Server Action verification:**
- [ ] saveAsResource extracts agent messages from conversation
- [ ] Workflow content includes request, steps, result with schema version
- [ ] Name validation (1-255 chars) enforced
- [ ] revalidatePath called after resource creation

**API route verification:**
- [ ] GET /api/resources requires authentication
- [ ] GET route calls getUserResources with userId and filters
- [ ] GET route accepts search and type query parameters
- [ ] GET route returns { resources: [...] } JSON response
- [ ] DELETE /api/resources/[id] requires authentication
- [ ] DELETE route calls deleteResource with resource ID and user ID
- [ ] Unauthorized users receive 401 response
- [ ] Successful deletion returns success: true

**UI component verification:**
- [ ] SaveResourceDialog has name and description inputs
- [ ] Dialog shows loading state during save
- [ ] Toast notifications for success/error
- [ ] ResourceBrowser fetches and displays resources
- [ ] Search and filter controls update resource list
- [ ] ResourceCard shows name, description, type, created date
- [ ] Execute and Delete buttons present (execute stub for now)
- [ ] Delete button calls DELETE /api/resources/[id]

**Page route verification:**
- [ ] /resources page requires authentication
- [ ] Page renders ResourceBrowser with userId
- [ ] Empty state shows helpful message
</verification>

<success_criteria>
1. User completes agent workflow → clicks "Save as Resource" → provides name → resource appears in browser
2. User visits /resources → sees list of saved resources with search box
3. User types "workflow" in search → list filters to matching resources
4. User selects "Workflows" filter → only workflow resources displayed
5. User clicks Delete on resource → confirms → resource removed from list
</success_criteria>

<output>
After completion, create `.planning/phases/05-resources-management-and-sharing/05-03-SUMMARY.md`
</output>
