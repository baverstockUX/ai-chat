---
phase: 05-resources-management-and-sharing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/db/schema.ts
  - lib/db/queries.ts
  - drizzle.config.ts
autonomous: true

must_haves:
  truths:
    - "Resource table exists with all required fields for storing workflows"
    - "Resource share table exists with token-based access control"
    - "Message table has attachments field for image metadata"
  artifacts:
    - path: "lib/db/schema.ts"
      provides: "resource and resourceShare table definitions"
      contains: "export const resource = pgTable"
    - path: "lib/db/queries.ts"
      provides: "Resource CRUD query functions"
      exports: ["createResource", "getUserResources", "getResourceById"]
  key_links:
    - from: "resource table"
      to: "user table"
      via: "userId foreign key"
      pattern: "references.*user\\.id.*onDelete.*cascade"
    - from: "resource table"
      to: "resource table"
      via: "parentResourceId foreign key"
      pattern: "parentResourceId.*references.*resource\\.id"
---

<objective>
Extend database schema with resource management tables, enabling users to save agent workflows as reusable templates with sharing and fork capabilities.

Purpose: Establish data model foundation for resource storage, sharing via tokens, fork lineage tracking, and image attachments. Follows Phase 2 pattern of JSONB for flexible content storage.

Output: Database schema with resource/resourceShare tables, query functions for resource CRUD operations, and migration applied.
</objective>

<execution_context>
@/Users/christian.baverstock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/christian.baverstock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-resources-management-and-sharing/05-RESEARCH.md
@.planning/phases/02-ai-orchestration-intent-detection/02-01-SUMMARY.md
@.planning/phases/01-chat-foundation-authentication/01-05-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create resource and resourceShare tables</name>
  <files>lib/db/schema.ts</files>
  <action>
Extend lib/db/schema.ts with two new tables following research Pattern 1:

**resource table:**
- id: uuid, defaultRandom, primaryKey
- userId: uuid, notNull, references user.id with onDelete: cascade
- name: varchar(255), notNull
- description: text, nullable
- resourceType: varchar(50) with enum ['workflow', 'prompt', 'agent_config'], default 'workflow', notNull
- content: jsonb, notNull (stores workflow steps, prompt text, config)
- executionCount: integer, default 0, notNull
- lastExecutedAt: timestamp, nullable
- parentResourceId: uuid, nullable, references resource.id with onDelete: set null (fork lineage)
- forkCount: integer, default 0, notNull
- isPublic: boolean, default false, notNull
- createdAt: timestamp, defaultNow, notNull
- updatedAt: timestamp, defaultNow, notNull

**resourceShare table:**
- id: uuid, defaultRandom, primaryKey
- resourceId: uuid, notNull, references resource.id with onDelete: cascade
- shareToken: varchar(32), notNull, unique (secure share URL token)
- expiresAt: timestamp, nullable
- accessCount: integer, default 0, notNull
- maxAccesses: integer, nullable
- createdAt: timestamp, defaultNow, notNull

**message table extension:**
Add attachments field to existing message table:
- attachments: jsonb, nullable (array of image metadata: [{type: 'image', url: '/uploads/...', mimeType: 'image/png'}])

Export types: Resource, NewResource, ResourceShare, NewResourceShare

Follow Phase 2 pattern: JSONB for flexible content, cascade delete for data integrity, timestamps with defaultNow.
  </action>
  <verify>
grep -A 5 "export const resource" lib/db/schema.ts
grep -A 5 "export const resourceShare" lib/db/schema.ts
grep "attachments" lib/db/schema.ts
  </verify>
  <done>resource and resourceShare tables defined with all fields, message table has attachments field, types exported</done>
</task>

<task type="auto">
  <name>Task 2: Create resource query functions</name>
  <files>lib/db/queries.ts</files>
  <action>
Add resource management query functions to lib/db/queries.ts following Phase 1 Server Actions pattern (auth guards, user isolation):

**createResource(input):**
- Input: { userId, name, description?, resourceType, content }
- Validation: name 1-255 chars
- Insert into resource table
- Return: created resource with id

**getUserResources(userId, filters?):**
- Input: userId, optional { search?, resourceType? }
- Query: Select from resource where userId = userId
- If search: WHERE name ILIKE %search% OR description ILIKE %search%
- If resourceType: AND resourceType = resourceType
- Order by: pinned DESC, updatedAt DESC
- Return: resource array

**getResourceById(resourceId, userId):**
- Input: resourceId, userId
- Query: Select from resource WHERE id = resourceId AND userId = userId
- Return: single resource or null (ownership check)

**updateResource(resourceId, userId, updates):**
- Input: resourceId, userId, { name?, description?, content? }
- Query: Update resource SET updates WHERE id = resourceId AND userId = userId
- Return: updated resource

**deleteResource(resourceId, userId):**
- Input: resourceId, userId
- Query: Delete from resource WHERE id = resourceId AND userId = userId
- Return: { success: boolean }

All functions use eq, and, or, ilike from drizzle-orm for query building.
  </action>
  <verify>
grep -A 10 "export async function createResource" lib/db/queries.ts
grep -A 10 "export async function getUserResources" lib/db/queries.ts
grep -A 10 "export async function getResourceById" lib/db/queries.ts
  </verify>
  <done>5 resource query functions implemented with user isolation and validation</done>
</task>

<task type="auto">
  <name>Task 3: Run database migration</name>
  <files>drizzle.config.ts</files>
  <action>
Generate and apply database migration for new tables:

1. Verify drizzle.config.ts loads .env.local (from Phase 2 fix)
2. Generate migration: npm run db:generate
3. Apply migration: npm run db:push
4. Verify tables exist: Check Drizzle Studio or psql

Expected migration adds:
- resource table with all columns and foreign keys
- resourceShare table with shareToken unique constraint
- message.attachments column (nullable JSONB)

If migration fails with environment error, ensure drizzle.config.ts has dotenv.config({ path: '.env.local' }) at top.
  </action>
  <verify>
npm run db:push
echo "SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name IN ('resource', 'resource_share');" | psql $DATABASE_URL
  </verify>
  <done>Migration applied successfully, resource and resource_share tables exist in database, message table has attachments column</done>
</task>

</tasks>

<verification>
**Schema verification:**
- [ ] resource table exists with 14 columns including parentResourceId for fork lineage
- [ ] resourceShare table exists with shareToken unique constraint
- [ ] message.attachments field added for image metadata
- [ ] Foreign keys have correct cascade/set null behavior

**Query function verification:**
- [ ] All 5 resource query functions exported from lib/db/queries.ts
- [ ] Functions use user isolation pattern (userId in WHERE clause)
- [ ] createResource validates name length
- [ ] getUserResources supports search and filter parameters

**Database integrity:**
- [ ] Migration applied without errors
- [ ] Can insert test resource and verify cascade delete on user deletion
</verification>

<success_criteria>
1. Developer can insert a resource via createResource() and it appears in database
2. getUserResources() returns only resources owned by specified user
3. Resource with parentResourceId correctly references another resource (fork lineage)
4. Deleting user cascades to delete their resources
5. resourceShare.shareToken is unique and generates no duplicate errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-resources-management-and-sharing/05-01-SUMMARY.md`
</output>
