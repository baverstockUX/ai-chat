---
phase: 05-resources-management-and-sharing
plan: 05
type: execute
wave: 3
depends_on: [05-03, 05-04]
files_modified:
  - app/(chat)/actions.ts
  - app/resources/share/[token]/page.tsx
  - components/resources/fork-dialog.tsx
  - components/resources/resource-card.tsx
  - app/api/resources/[id]/execute/route.ts
autonomous: true

must_haves:
  truths:
    - "User can fork shared resource to create independent copy"
    - "Forked resource shows lineage (forked from X)"
    - "User can execute saved resource workflow"
    - "Original resource unchanged when fork modified"
  artifacts:
    - path: "app/(chat)/actions.ts"
      provides: "forkResource Server Action"
      exports: ["forkResource", "executeResource"]
    - path: "app/resources/share/[token]/page.tsx"
      provides: "Shared resource view page"
    - path: "components/resources/fork-dialog.tsx"
      provides: "Fork confirmation UI"
  key_links:
    - from: "forkResource"
      to: "resource table"
      via: "insert with parentResourceId"
      pattern: "parentResourceId.*originalResource\\.id"
    - from: "ResourceCard"
      to: "executeResource"
      via: "Server Action call"
      pattern: "await executeResource"
---

<objective>
Enable users to fork shared resources with lineage tracking and execute saved workflow resources, completing the resource lifecycle (view → fork → modify → execute).

Purpose: Implement fork functionality (RES-09, RES-10, RES-11) and resource execution (RES-06) following research Pattern 4 with parent tracking and SQL increment operations.

Output: Fork Server Action, fork dialog, shared resource view page, and resource execution capability.
</objective>

<execution_context>
@/Users/christian.baverstock/.claude/get-shit-done/workflows/execute-plan.md
@/Users/christian.baverstock/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-resources-management-and-sharing/05-RESEARCH.md
@.planning/phases/05-resources-management-and-sharing/05-01-SUMMARY.md
@.planning/phases/05-resources-management-and-sharing/05-03-SUMMARY.md
@.planning/phases/05-resources-management-and-sharing/05-04-SUMMARY.md
@.planning/phases/03-agent-execution-basic-visibility/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create fork and execute Server Actions</name>
  <files>app/(chat)/actions.ts</files>
  <action>
Add forkResource and executeResource Server Actions to app/(chat)/actions.ts:

**1. forkResource following research Pattern 4:**
```typescript
'use server';

import { auth } from '@/app/(auth)/auth';
import { db } from '@/lib/db';
import { resource } from '@/lib/db/schema';
import { eq, sql } from 'drizzle-orm';
import { revalidatePath } from 'next/cache';

export async function forkResource(resourceId: string) {
  const session = await auth();
  if (!session?.user?.id) throw new Error('Unauthorized');

  // Fetch original resource (no ownership check - can fork shared resources)
  const [originalResource] = await db
    .select()
    .from(resource)
    .where(eq(resource.id, resourceId))
    .limit(1);

  if (!originalResource) {
    throw new Error('Resource not found');
  }

  // Create forked resource
  const [forkedResource] = await db
    .insert(resource)
    .values({
      userId: session.user.id,
      name: `${originalResource.name} (Fork)`,
      description: originalResource.description,
      resourceType: originalResource.resourceType,
      content: originalResource.content, // Deep copy JSONB
      parentResourceId: originalResource.id, // Track lineage
      isPublic: false, // Forked resources private by default
    })
    .returning();

  // Increment fork count on original
  await db
    .update(resource)
    .set({
      forkCount: sql`${resource.forkCount} + 1`,
    })
    .where(eq(resource.id, resourceId));

  revalidatePath('/resources');
  return { success: true, resourceId: forkedResource.id };
}
```

**2. executeResource:**
```typescript
export async function executeResource(resourceId: string) {
  const session = await auth();
  if (!session?.user?.id) throw new Error('Unauthorized');

  // Fetch resource with ownership check
  const [resourceData] = await db
    .select()
    .from(resource)
    .where(
      and(
        eq(resource.id, resourceId),
        eq(resource.userId, session.user.id)
      )
    )
    .limit(1);

  if (!resourceData) {
    throw new Error('Resource not found or unauthorized');
  }

  // Extract workflow content
  const workflowContent = resourceData.content as any;
  const agentRequest = workflowContent.request;

  if (!agentRequest) {
    throw new Error('Invalid resource content: missing request');
  }

  // Update execution metadata
  await db
    .update(resource)
    .set({
      executionCount: sql`${resource.executionCount} + 1`,
      lastExecutedAt: new Date(),
    })
    .where(eq(resource.id, resourceId));

  // Return agent request for execution
  // (actual execution handled by existing agent infrastructure)
  return {
    success: true,
    agentRequest,
    resourceId,
  };
}
```

Uses sql template for atomic increments (prevents race conditions).
  </action>
  <verify>
grep -A 50 "export async function forkResource" app/(chat)/actions.ts
grep -A 40 "export async function executeResource" app/(chat)/actions.ts
grep "sql\`.*forkCount.*+ 1" app/(chat)/actions.ts
  </verify>
  <done>forkResource and executeResource Server Actions with lineage tracking and execution counting</done>
</task>

<task type="auto">
  <name>Task 2: Create shared resource view page and fork dialog</name>
  <files>app/resources/share/[token]/page.tsx, components/resources/fork-dialog.tsx</files>
  <action>
1. Create shared resource view page:

app/resources/share/[token]/page.tsx:
```typescript
import { Button } from '@/components/ui/button';
import { Card, CardHeader, CardTitle, CardContent, CardFooter } from '@/components/ui/card';
import Link from 'next/link';

export default async function SharedResourcePage({
  params,
}: {
  params: { token: string };
}) {
  // Fetch resource from share API
  const response = await fetch(
    `${process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000'}/api/resources/share/${params.token}`,
    { cache: 'no-store' }
  );

  if (!response.ok) {
    const error = await response.json();
    return (
      <div className="container mx-auto py-16 text-center">
        <h1 className="text-2xl font-bold mb-4">Share Link Error</h1>
        <p className="text-muted-foreground">{error.error || 'Failed to load resource'}</p>
        <Link href="/login">
          <Button className="mt-4">Go to Login</Button>
        </Link>
      </div>
    );
  }

  const { resource } = await response.json();
  const workflowContent = resource.content as any;

  return (
    <div className="container mx-auto py-8">
      <Card>
        <CardHeader>
          <CardTitle className="text-2xl">{resource.name}</CardTitle>
          <p className="text-sm text-muted-foreground">
            {resource.resourceType} · {resource.forkCount} forks · {resource.executionCount} executions
          </p>
        </CardHeader>
        <CardContent className="space-y-4">
          <div>
            <h3 className="font-semibold mb-2">Description</h3>
            <p className="text-muted-foreground">
              {resource.description || 'No description provided'}
            </p>
          </div>

          <div>
            <h3 className="font-semibold mb-2">Workflow</h3>
            <div className="bg-muted p-4 rounded-md">
              <p className="text-sm font-mono">
                {workflowContent.request || 'Workflow details not available'}
              </p>
              {workflowContent.steps && (
                <p className="text-xs text-muted-foreground mt-2">
                  {workflowContent.steps.length} steps
                </p>
              )}
            </div>
          </div>
        </CardContent>
        <CardFooter>
          <Link href={`/resources/fork/${resource.id}`}>
            <Button>Fork This Resource</Button>
          </Link>
        </CardFooter>
      </Card>
    </div>
  );
}
```

2. Create ForkDialog component:

components/resources/fork-dialog.tsx:
```typescript
'use client';

import { useState } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { forkResource } from '@/app/(chat)/actions';
import { toast } from 'sonner';
import { useRouter } from 'next/navigation';

interface ForkDialogProps {
  resourceId: string;
  resourceName: string;
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export function ForkDialog(props: ForkDialogProps) {
  const [forking, setForking] = useState(false);
  const router = useRouter();

  const handleFork = async () => {
    setForking(true);
    try {
      const result = await forkResource(props.resourceId);

      if (result.success) {
        toast.success('Resource forked successfully');
        props.onOpenChange(false);
        router.push('/resources');
        router.refresh();
      }
    } catch (error) {
      console.error('Fork error:', error);
      toast.error(error instanceof Error ? error.message : 'Failed to fork resource');
    } finally {
      setForking(false);
    }
  };

  return (
    <Dialog open={props.open} onOpenChange={props.onOpenChange}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Fork Resource</DialogTitle>
        </DialogHeader>
        <div className="space-y-4">
          <p className="text-sm">
            Create your own copy of "{props.resourceName}" that you can modify and execute independently.
          </p>
          <div className="bg-muted p-3 rounded-md text-sm">
            <p className="font-semibold mb-1">What happens when you fork:</p>
            <ul className="list-disc list-inside space-y-1 text-muted-foreground">
              <li>A new resource is created in your workspace</li>
              <li>The original resource remains unchanged</li>
              <li>Your fork shows "Forked from original"</li>
              <li>You can modify and execute your copy freely</li>
            </ul>
          </div>
          <div className="flex gap-2 justify-end">
            <Button variant="outline" onClick={() => props.onOpenChange(false)}>
              Cancel
            </Button>
            <Button onClick={handleFork} disabled={forking}>
              {forking ? 'Forking...' : 'Fork Resource'}
            </Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}
```

Uses router.push to redirect after fork, router.refresh to update resource list.
  </action>
  <verify>
grep -A 50 "export default async function SharedResourcePage" app/resources/share/[token]/page.tsx
grep -A 50 "export function ForkDialog" components/resources/fork-dialog.tsx
grep "forkResource" components/resources/fork-dialog.tsx
  </verify>
  <done>Shared resource view page with preview, ForkDialog with explanation and redirect</done>
</task>

<task type="auto">
  <name>Task 3: Integrate execute and fork into ResourceCard</name>
  <files>components/resources/resource-card.tsx, app/api/resources/[id]/execute/route.ts</files>
  <action>
1. Update ResourceCard to handle execution:

In components/resources/resource-card.tsx:
```typescript
import { executeResource, forkResource } from '@/app/(chat)/actions';
import { ForkDialog } from './fork-dialog';
import { useRouter } from 'next/navigation';

// Add state for fork dialog
const [forkDialogOpen, setForkDialogOpen] = useState(false);
const router = useRouter();

// Update handleExecute
const handleExecute = async () => {
  try {
    const result = await executeResource(resource.id);

    if (result.success && result.agentRequest) {
      // Navigate to chat with execution context
      // Store in localStorage or create new conversation with agent request
      toast.success('Starting workflow execution...');
      router.push('/'); // Navigate to chat

      // TODO: Trigger agent execution with result.agentRequest
      // This will be integrated with existing agent execution infrastructure
    }
  } catch (error) {
    console.error('Failed to execute resource:', error);
    toast.error(error instanceof Error ? error.message : 'Failed to execute resource');
  }
};

// Add Fork button (only for forked resources or shared resources)
{!resource.parentResourceId && (
  <Button
    variant="outline"
    size="sm"
    onClick={() => setForkDialogOpen(true)}
  >
    Fork
  </Button>
)}

// Add ForkDialog at end
<ForkDialog
  resourceId={resource.id}
  resourceName={resource.name}
  open={forkDialogOpen}
  onOpenChange={setForkDialogOpen}
/>
```

2. Create execution API route (optional, for future REST API):

app/api/resources/[id]/execute/route.ts:
```typescript
import { auth } from '@/app/(auth)/auth';
import { db } from '@/lib/db';
import { resource } from '@/lib/db/schema';
import { eq, and, sql } from 'drizzle-orm';
import { NextResponse } from 'next/server';

export async function POST(
  req: Request,
  { params }: { params: { id: string } }
) {
  const session = await auth();
  if (!session?.user?.id) {
    return new Response('Unauthorized', { status: 401 });
  }

  // Fetch and execute resource
  const [resourceData] = await db
    .select()
    .from(resource)
    .where(
      and(
        eq(resource.id, params.id),
        eq(resource.userId, session.user.id)
      )
    )
    .limit(1);

  if (!resourceData) {
    return NextResponse.json({ error: 'Resource not found' }, { status: 404 });
  }

  // Increment execution count
  await db
    .update(resource)
    .set({
      executionCount: sql`${resource.executionCount} + 1`,
      lastExecutedAt: new Date(),
    })
    .where(eq(resource.id, params.id));

  return NextResponse.json({
    success: true,
    agentRequest: (resourceData.content as any).request,
  });
}
```

Execution triggers existing agent infrastructure from Phase 3.
  </action>
  <verify>
grep "executeResource" components/resources/resource-card.tsx
grep "ForkDialog" components/resources/resource-card.tsx
grep -A 30 "export async function POST" app/api/resources/[id]/execute/route.ts
  </verify>
  <done>ResourceCard integrated with execute and fork functionality, execution API route created</done>
</task>

</tasks>

<verification>
**Fork functionality verification:**
- [ ] forkResource creates copy with parentResourceId set
- [ ] Original resource forkCount increments atomically
- [ ] Forked resource private by default (isPublic: false)
- [ ] Fork name appends " (Fork)" to original name
- [ ] ForkDialog explains fork behavior to user

**Execute functionality verification:**
- [ ] executeResource validates ownership
- [ ] executionCount and lastExecutedAt updated
- [ ] Returns agent request from resource content
- [ ] ResourceCard Execute button triggers execution

**Shared resource page verification:**
- [ ] Page loads resource from share token
- [ ] Shows workflow preview with step count
- [ ] Fork button navigates to fork flow
- [ ] Error page shows clear message for invalid/expired links
</verification>

<success_criteria>
1. User opens share link → sees resource preview → clicks Fork → resource appears in their workspace
2. User executes forked resource → executionCount increments → agent starts execution
3. User modifies forked resource → original unchanged → fork shows "Forked from original"
4. Original resource owner checks forkCount → sees accurate count of forks
5. User tries to execute resource they don't own → "unauthorized" error
</success_criteria>

<output>
After completion, create `.planning/phases/05-resources-management-and-sharing/05-05-SUMMARY.md`
</output>
